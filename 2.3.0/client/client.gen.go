// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ChargingFacilitiesTypeChargingModes.
const (
	ChargingFacilitiesTypeChargingModesCHAdeMO ChargingFacilitiesTypeChargingModes = "CHAdeMO"
	ChargingFacilitiesTypeChargingModesMode1   ChargingFacilitiesTypeChargingModes = "Mode_1"
	ChargingFacilitiesTypeChargingModesMode2   ChargingFacilitiesTypeChargingModes = "Mode_2"
	ChargingFacilitiesTypeChargingModesMode3   ChargingFacilitiesTypeChargingModes = "Mode_3"
	ChargingFacilitiesTypeChargingModesMode4   ChargingFacilitiesTypeChargingModes = "Mode_4"
)

// Defines values for ChargingFacilitiesTypePowerType.
const (
	AC1PHASE ChargingFacilitiesTypePowerType = "AC_1_PHASE"
	AC3PHASE ChargingFacilitiesTypePowerType = "AC_3_PHASE"
	DC       ChargingFacilitiesTypePowerType = "DC"
)

// Defines values for ChargingNotificationType.
const (
	ChargingNotificationTypeEnd      ChargingNotificationType = "End"
	ChargingNotificationTypeError    ChargingNotificationType = "Error"
	ChargingNotificationTypeProgress ChargingNotificationType = "Progress"
	ChargingNotificationTypeStart    ChargingNotificationType = "Start"
)

// Defines values for EvseDataRecordAccessibility.
const (
	FreePubliclyAccessible   EvseDataRecordAccessibility = "Free publicly accessible"
	PayingPubliclyAccessible EvseDataRecordAccessibility = "Paying publicly accessible"
	RestrictedAccess         EvseDataRecordAccessibility = "Restricted access"
	TestStation              EvseDataRecordAccessibility = "Test Station"
)

// Defines values for EvseDataRecordAccessibilityLocation.
const (
	OnStreet                 EvseDataRecordAccessibilityLocation = "OnStreet"
	ParkingGarage            EvseDataRecordAccessibilityLocation = "ParkingGarage"
	ParkingLot               EvseDataRecordAccessibilityLocation = "ParkingLot"
	UndergroundParkingGarage EvseDataRecordAccessibilityLocation = "UndergroundParkingGarage"
)

// Defines values for EvseDataRecordAuthenticationModes.
const (
	DirectPayment            EvseDataRecordAuthenticationModes = "Direct Payment"
	NFCRFIDClassic           EvseDataRecordAuthenticationModes = "NFC RFID Classic"
	NFCRFIDDESFire           EvseDataRecordAuthenticationModes = "NFC RFID DESFire"
	NoAuthenticationRequired EvseDataRecordAuthenticationModes = "No Authentication Required"
	PnC                      EvseDataRecordAuthenticationModes = "PnC"
	REMOTE                   EvseDataRecordAuthenticationModes = "REMOTE"
)

// Defines values for EvseDataRecordCalibrationLawDataAvailability.
const (
	External     EvseDataRecordCalibrationLawDataAvailability = "External"
	Local        EvseDataRecordCalibrationLawDataAvailability = "Local"
	NotAvailable EvseDataRecordCalibrationLawDataAvailability = "Not Available"
)

// Defines values for EvseDataRecordDynamicInfoAvailable.
const (
	Auto  EvseDataRecordDynamicInfoAvailable = "auto"
	False EvseDataRecordDynamicInfoAvailable = "false"
	True  EvseDataRecordDynamicInfoAvailable = "true"
)

// Defines values for EvseDataRecordEnergySourceEnergy.
const (
	Biomass          EvseDataRecordEnergySourceEnergy = "Biomass"
	Coal             EvseDataRecordEnergySourceEnergy = "Coal"
	GeothermalEnergy EvseDataRecordEnergySourceEnergy = "GeothermalEnergy"
	HydroPower       EvseDataRecordEnergySourceEnergy = "HydroPower"
	NaturalGas       EvseDataRecordEnergySourceEnergy = "NaturalGas"
	NuclearEnergy    EvseDataRecordEnergySourceEnergy = "NuclearEnergy"
	Petroleum        EvseDataRecordEnergySourceEnergy = "Petroleum"
	Solar            EvseDataRecordEnergySourceEnergy = "Solar"
	Wind             EvseDataRecordEnergySourceEnergy = "Wind"
)

// Defines values for EvseDataRecordPaymentOptions.
const (
	Contract  EvseDataRecordPaymentOptions = "Contract"
	Direct    EvseDataRecordPaymentOptions = "Direct"
	NoPayment EvseDataRecordPaymentOptions = "No Payment"
)

// Defines values for EvseDataRecordPlugs.
const (
	EvseDataRecordPlugsAVCONConnector              EvseDataRecordPlugs = "AVCON Connector"
	EvseDataRecordPlugsCCSCombo1PlugCableAttached  EvseDataRecordPlugs = "CCS Combo 1 Plug (Cable Attached)"
	EvseDataRecordPlugsCCSCombo2PlugCableAttached  EvseDataRecordPlugs = "CCS Combo 2 Plug (Cable Attached)"
	EvseDataRecordPlugsCHAdeMO                     EvseDataRecordPlugs = "CHAdeMO"
	EvseDataRecordPlugsIEC60309SinglePhase         EvseDataRecordPlugs = "IEC 60309 Single Phase"
	EvseDataRecordPlugsIEC60309ThreePhase          EvseDataRecordPlugs = "IEC 60309 Three Phase"
	EvseDataRecordPlugsLargePaddleInductive        EvseDataRecordPlugs = "Large Paddle Inductive"
	EvseDataRecordPlugsNEMA520                     EvseDataRecordPlugs = "NEMA 5-20"
	EvseDataRecordPlugsSmallPaddleInductive        EvseDataRecordPlugs = "Small Paddle Inductive"
	EvseDataRecordPlugsTeslaConnector              EvseDataRecordPlugs = "Tesla Connector"
	EvseDataRecordPlugsType1ConnectorCableAttached EvseDataRecordPlugs = "Type 1 Connector (Cable Attached)"
	EvseDataRecordPlugsType2ConnectorCableAttached EvseDataRecordPlugs = "Type 2 Connector (Cable Attached)"
	EvseDataRecordPlugsType2Outlet                 EvseDataRecordPlugs = "Type 2 Outlet"
	EvseDataRecordPlugsType3Outlet                 EvseDataRecordPlugs = "Type 3 Outlet"
	EvseDataRecordPlugsTypeEFrenchStandard         EvseDataRecordPlugs = "Type E French Standard"
	EvseDataRecordPlugsTypeFSchuko                 EvseDataRecordPlugs = "Type F Schuko"
	EvseDataRecordPlugsTypeGBritishStandard        EvseDataRecordPlugs = "Type G British Standard"
	EvseDataRecordPlugsTypeJSwissStandard          EvseDataRecordPlugs = "Type J Swiss Standard"
)

// Defines values for EvseDataRecordValueAddedServices.
const (
	ChargingPlans              EvseDataRecordValueAddedServices = "ChargingPlans"
	DynamicPricing             EvseDataRecordValueAddedServices = "DynamicPricing"
	MaximumPowerCharging       EvseDataRecordValueAddedServices = "MaximumPowerCharging"
	None                       EvseDataRecordValueAddedServices = "None"
	ParkingSensors             EvseDataRecordValueAddedServices = "ParkingSensors"
	PredictiveChargePointUsage EvseDataRecordValueAddedServices = "PredictiveChargePointUsage"
	Reservation                EvseDataRecordValueAddedServices = "Reservation"
	RoofProvided               EvseDataRecordValueAddedServices = "RoofProvided"
)

// Defines values for EvseDataRecordDeltaType.
const (
	EvseDataRecordDeltaTypeDelete EvseDataRecordDeltaType = "delete"
	EvseDataRecordDeltaTypeInsert EvseDataRecordDeltaType = "insert"
	EvseDataRecordDeltaTypeUpdate EvseDataRecordDeltaType = "update"
)

// Defines values for EvseStatusRecordEvseStatus.
const (
	Available    EvseStatusRecordEvseStatus = "Available"
	EvseNotFound EvseStatusRecordEvseStatus = "EvseNotFound"
	Occupied     EvseStatusRecordEvseStatus = "Occupied"
	OutOfService EvseStatusRecordEvseStatus = "OutOfService"
	Reserved     EvseStatusRecordEvseStatus = "Reserved"
	Unknown      EvseStatusRecordEvseStatus = "Unknown"
)

// Defines values for OpeningTimesOn.
const (
	OpeningTimesOnEveryday  OpeningTimesOn = "Everyday"
	OpeningTimesOnFriday    OpeningTimesOn = "Friday"
	OpeningTimesOnMonday    OpeningTimesOn = "Monday"
	OpeningTimesOnSaturday  OpeningTimesOn = "Saturday"
	OpeningTimesOnSunday    OpeningTimesOn = "Sunday"
	OpeningTimesOnThursday  OpeningTimesOn = "Thursday"
	OpeningTimesOnTuesday   OpeningTimesOn = "Tuesday"
	OpeningTimesOnWednesday OpeningTimesOn = "Wednesday"
	OpeningTimesOnWeekend   OpeningTimesOn = "Weekend"
	OpeningTimesOnWorkdays  OpeningTimesOn = "Workdays"
)

// Defines values for PricingProductDataRecordAdditionalReferencesAdditionalReference.
const (
	FIXEDFEE   PricingProductDataRecordAdditionalReferencesAdditionalReference = "FIXED FEE"
	MAXIMUMFEE PricingProductDataRecordAdditionalReferencesAdditionalReference = "MAXIMUM FEE"
	MINIMUMFEE PricingProductDataRecordAdditionalReferencesAdditionalReference = "MINIMUM FEE"
	PARKINGFEE PricingProductDataRecordAdditionalReferencesAdditionalReference = "PARKING FEE"
	STARTFEE   PricingProductDataRecordAdditionalReferencesAdditionalReference = "START FEE"
)

// Defines values for PricingProductDataRecordProductAvailabilityTimesOn.
const (
	PricingProductDataRecordProductAvailabilityTimesOnEveryday  PricingProductDataRecordProductAvailabilityTimesOn = "Everyday"
	PricingProductDataRecordProductAvailabilityTimesOnFriday    PricingProductDataRecordProductAvailabilityTimesOn = "Friday"
	PricingProductDataRecordProductAvailabilityTimesOnMonday    PricingProductDataRecordProductAvailabilityTimesOn = "Monday"
	PricingProductDataRecordProductAvailabilityTimesOnSaturday  PricingProductDataRecordProductAvailabilityTimesOn = "Saturday"
	PricingProductDataRecordProductAvailabilityTimesOnSunday    PricingProductDataRecordProductAvailabilityTimesOn = "Sunday"
	PricingProductDataRecordProductAvailabilityTimesOnThursday  PricingProductDataRecordProductAvailabilityTimesOn = "Thursday"
	PricingProductDataRecordProductAvailabilityTimesOnTuesday   PricingProductDataRecordProductAvailabilityTimesOn = "Tuesday"
	PricingProductDataRecordProductAvailabilityTimesOnWednesday PricingProductDataRecordProductAvailabilityTimesOn = "Wednesday"
	PricingProductDataRecordProductAvailabilityTimesOnWeekend   PricingProductDataRecordProductAvailabilityTimesOn = "Weekend"
	PricingProductDataRecordProductAvailabilityTimesOnWorkdays  PricingProductDataRecordProductAvailabilityTimesOn = "Workdays"
)

// Defines values for QRCodeIdentificationHashedPINFunction.
const (
	Bcrypt QRCodeIdentificationHashedPINFunction = "Bcrypt"
)

// Defines values for QRCodeIdentificationHashedPINLegacyHashDataFunction.
const (
	MD5  QRCodeIdentificationHashedPINLegacyHashDataFunction = "MD5"
	SHA1 QRCodeIdentificationHashedPINLegacyHashDataFunction = "SHA-1"
)

// Defines values for RFIDIdentificationRFID.
const (
	Calypso      RFIDIdentificationRFID = "calypso"
	MifareCls    RFIDIdentificationRFID = "mifareCls"
	MifareDes    RFIDIdentificationRFID = "mifareDes"
	MifareFamily RFIDIdentificationRFID = "mifareFamily"
	Nfc          RFIDIdentificationRFID = "nfc"
)

// Defines values for ERoamingAuthorizationStartAuthorizationStatus.
const (
	ERoamingAuthorizationStartAuthorizationStatusAuthorized    ERoamingAuthorizationStartAuthorizationStatus = "Authorized"
	ERoamingAuthorizationStartAuthorizationStatusNotAuthorized ERoamingAuthorizationStartAuthorizationStatus = "NotAuthorized"
)

// Defines values for ERoamingAuthorizationStopAuthorizationStatus.
const (
	ERoamingAuthorizationStopAuthorizationStatusAuthorized    ERoamingAuthorizationStopAuthorizationStatus = "Authorized"
	ERoamingAuthorizationStopAuthorizationStatusNotAuthorized ERoamingAuthorizationStopAuthorizationStatus = "NotAuthorized"
)

// Defines values for ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus.
const (
	ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatusEnd      ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus = "End"
	ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatusProgress ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus = "Progress"
	ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatusStart    ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus = "Start"
)

// Defines values for ERoamingChargingNotificationErrorErrorType.
const (
	ERoamingChargingNotificationErrorErrorTypeConnectorError ERoamingChargingNotificationErrorErrorType = "ConnectorError"
	ERoamingChargingNotificationErrorErrorTypeCriticalError  ERoamingChargingNotificationErrorErrorType = "CriticalError"
)

// Defines values for ERoamingPushEVSEPricingActionType.
const (
	ERoamingPushEVSEPricingActionTypeDelete   ERoamingPushEVSEPricingActionType = "delete"
	ERoamingPushEVSEPricingActionTypeFullLoad ERoamingPushEVSEPricingActionType = "fullLoad"
	ERoamingPushEVSEPricingActionTypeInsert   ERoamingPushEVSEPricingActionType = "insert"
	ERoamingPushEVSEPricingActionTypeUpdate   ERoamingPushEVSEPricingActionType = "update"
)

// Defines values for ERoamingPushEvseDataActionType.
const (
	ERoamingPushEvseDataActionTypeDelete   ERoamingPushEvseDataActionType = "delete"
	ERoamingPushEvseDataActionTypeFullLoad ERoamingPushEvseDataActionType = "fullLoad"
	ERoamingPushEvseDataActionTypeInsert   ERoamingPushEvseDataActionType = "insert"
	ERoamingPushEvseDataActionTypeUpdate   ERoamingPushEvseDataActionType = "update"
)

// Defines values for ERoamingPushEvseStatusActionType.
const (
	ERoamingPushEvseStatusActionTypeDelete   ERoamingPushEvseStatusActionType = "delete"
	ERoamingPushEvseStatusActionTypeFullLoad ERoamingPushEvseStatusActionType = "fullLoad"
	ERoamingPushEvseStatusActionTypeInsert   ERoamingPushEvseStatusActionType = "insert"
	ERoamingPushEvseStatusActionTypeUpdate   ERoamingPushEvseStatusActionType = "update"
)

// Defines values for ERoamingPushPricingProductDataActionType.
const (
	Delete   ERoamingPushPricingProductDataActionType = "delete"
	FullLoad ERoamingPushPricingProductDataActionType = "fullLoad"
	Insert   ERoamingPushPricingProductDataActionType = "insert"
	Update   ERoamingPushPricingProductDataActionType = "update"
)

// Defines values for ERoamingChargingNotificationsV11JSONBodyErrorType.
const (
	ERoamingChargingNotificationsV11JSONBodyErrorTypeConnectorError ERoamingChargingNotificationsV11JSONBodyErrorType = "ConnectorError"
	ERoamingChargingNotificationsV11JSONBodyErrorTypeCriticalError  ERoamingChargingNotificationsV11JSONBodyErrorType = "CriticalError"
)

// Address defines model for Address.
type Address struct {
	City string `json:"City"`

	// Country The CountryCodeType allows for Alpha-3 country codes only as of OICP 2.2 and OICP 2.3
	//
	// For Alpha-3 (three-letter) country codes as defined in ISO 3166-1.
	//
	// __Examples:__
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | AUT | Austria |
	// | DEU | Germany |
	// | FRA | France |
	// | USA | United States |
	Country         string  `json:"Country"`
	Floor           *string `json:"Floor,omitempty"`
	HouseNum        string  `json:"HouseNum"`
	ParkingFacility *bool   `json:"ParkingFacility,omitempty"`
	ParkingSpot     *string `json:"ParkingSpot,omitempty"`
	PostalCode      string  `json:"PostalCode"`
	Region          *string `json:"Region,omitempty"`
	Street          string  `json:"Street"`

	// TimeZone `[U][T][C][+,-][0-9][0-9][:][0-9][0-9]`
	// The expression validates a string as a Time zone with UTC offset.
	//
	// Examples:
	//
	// UTC+01:00
	//
	// UTC-05:00
	TimeZone *string `json:"TimeZone,omitempty"`
}

// ChargingFacilitiesType defines model for ChargingFacilitiesType.
type ChargingFacilitiesType struct {
	// Amperage Amperage of the Charging Facility
	Amperage *int `json:"Amperage,omitempty"`

	// ChargingModes List of charging modes that are supported.
	ChargingModes *[]ChargingFacilitiesTypeChargingModes `json:"ChargingModes,omitempty"`

	// Power Charging Facility power in kW
	Power int `json:"Power"`

	// PowerType Charging Facility power type (e.g. AC or DC)
	PowerType ChargingFacilitiesTypePowerType `json:"PowerType"`

	// Voltage Voltage (Line to Neutral) of the Charging Facility
	Voltage *int `json:"Voltage,omitempty"`
}

// ChargingFacilitiesTypeChargingModes | Option | Description |
// | Mode_1 | conductive connection between a standard socket-outlet of an AC supply network and electric vehicle without communication or additional safety features (IEC 61851-1) |
// | Mode_2 | conductive connection between a standard socket-outlet of an AC supply network and electric vehicle with communication and additional safety features (IEC 61851-1) |
// | Mode_3 | conductive connection of an EV to an AC EV supply equipment permanently connected to an AC supply network with communication and additional safety features (IEC 61851-1) |
// | Mode_4 | conductive connection of an EV to an AC or DC supply network utilizing a DC EV supply equipment, with (high-level) communication and additional safety features (IEC 61851-1) |
// | CHAdeMO | CHAdeMo Specification |
type ChargingFacilitiesTypeChargingModes string

// ChargingFacilitiesTypePowerType Charging Facility power type (e.g. AC or DC)
type ChargingFacilitiesTypePowerType string

// ChargingNotificationType The type of ChargingNotification
type ChargingNotificationType string

// CurrencyID The ProductPriceCurrencyType allows for the list of active codes of the official ISO 4217 currency names.
//
// For the full list of active codes of the official ISO 4217 currencies, see: [https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)
//
// Examples:
//
// | Option | Description |
// | ------ | ----------- |
// | EUR | Euro |
// | CHF | Swiss franc |
// | CAD | Canadian Dollar |
// | GBP | Pound sterling
type CurrencyID = string

// DecimalDegreeType Geocoordinates using DecimalDegree Structure
type DecimalDegreeType struct {
	// Latitude A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^-?1?\d{1,2}\.\d{1,6}$`
	// The expression validates the string as a geo coordinate (longitude or latitude) with decimal degree syntax.
	//
	// Examples: “9.360922”, “-21.568201”
	Latitude string `json:"Latitude"`

	// Longitude A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^-?1?\d{1,2}\.\d{1,6}$`
	// The expression validates the string as a geo coordinate (longitude or latitude) with decimal degree syntax.
	//
	// Examples: “9.360922”, “-21.568201”
	Longitude string `json:"Longitude"`
}

// DegreeMinuteSecondsType Geocoordinates using DegreeMinutesSeconds Structure
type DegreeMinuteSecondsType struct {
	// Latitude A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^-?1?\d{1,2}°[ ]?\d{1,2}'[ ]?\d{1,2}\.\d+''$`
	// The expression validates the string as a geo coordinate (longitude or latitude) consisting of degree, minutes, and seconds
	//
	// Examples: “9°21'39.32''”, “-21°34'23.16''
	Latitude string `json:"Latitude"`

	// Longitude A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^-?1?\d{1,2}°[ ]?\d{1,2}'[ ]?\d{1,2}\.\d+''$`
	// The expression validates the string as a geo coordinate (longitude or latitude) consisting of degree, minutes, and seconds
	//
	// Examples: “9°21'39.32''”, “-21°34'23.16''
	Longitude string `json:"Longitude"`
}

// EvcoID A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
//
// ^(([A-Za-z]{2}\-?[A-Za-z0-9]{3}\-?C[A-Za-z0-9]{8}\-?[\d|A-Za-z])|([A-Za-z]{2}[\*|\-]?[A-Za-z0-9]{3}[\*|\-]?[A-Za-z0-9]{6}[\*|\-]?[\d|X]))$
// The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
//
// In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.
//
// In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.
//
// Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”
//
// Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
type EvcoID = string

// EvseDataRecord defines model for EvseDataRecord.
type EvseDataRecord struct {
	// Accessibility Specifies how the charging station can be accessed.
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | Free publicly accessible | EV Driver can reach the charging point without paying a fee, e.g. street, free public place, free parking lot, etc. |
	// | Restricted access | EV Driver needs permission to reach the charging point, e.g. Campus, building complex, etc. |
	// | Paying publicly accessible | EV Driver needs to pay a fee in order to reach the charging point, e.g. payable parking garage, etc. |
	// | Test Station | Station is just for testing purposes. Access may be restricted. |
	Accessibility EvseDataRecordAccessibility `json:"Accessibility"`

	// AccessibilityLocation | Option | Description |
	// | ------ | ----------- |
	// | OnStreet | The charging station is located on the street|
	// | ParkingLot | The Charging Point is located inside a Parking Lot|
	// | ParkingGarage | The Charging Point is located inside a Parking Garage|
	// | UndergroundParkingGarage | The Charging Point is located inside an Underground Parking Garage |
	AccessibilityLocation *EvseDataRecordAccessibilityLocation `json:"AccessibilityLocation,omitempty"`

	// AdditionalInfo Optional information.
	AdditionalInfo *[]InfoTextType `json:"AdditionalInfo,omitempty"`
	Address        Address         `json:"Address"`

	// AuthenticationModes List of authentication modes that are supported.
	AuthenticationModes []EvseDataRecordAuthenticationModes `json:"AuthenticationModes"`

	// CalibrationLawDataAvailability | Option | Description |
	// | Local | Calibration law data is shown at the charging station. |
	// | External | Calibration law data is provided externaly. |
	// | Not Available | Calibration law data is not provided. |
	CalibrationLawDataAvailability EvseDataRecordCalibrationLawDataAvailability `json:"CalibrationLawDataAvailability"`
	ChargingFacilities             []ChargingFacilitiesType                     `json:"ChargingFacilities"`

	// ChargingPoolID VSEs may be grouped by using a charging pool id according to emi³ standard definition. The Evse Pool ID MUST match the following structure (the notation corresponds to the augmented Backus-Naur Form (ABNF) as defined in RFC5234):
	// <Evse Pool ID> = <Country Code> <S> <Spot Operator ID> <S> <ID Type> <Pool ID>
	//
	// with:
	//
	// <Country Code> = 2 ALPHA ; two character country code according to ISO-3166-1 (Alpha-2-Code).
	//
	// <Spot Operator ID> = 3 (ALPHA / DIGIT); three alphanumeric characters.
	//
	// <ID Type> = “P”; one character “P” indicating that this ID represents a “Pool”.
	//
	// <Pool Instance> = (ALPHA / DIGIT) 1 * 30 ( 1*(ALPHA / DIGIT) [/ <S>] ); between 1 and 31sequence of alphanumeric characters, including additional optional separators. Starts with alphanumeric character referring to a specific Pool in EVSE Operator data system.
	//
	// ALPHA = %x41-5A / %x61-7A; according to RFC 5234 (7-Bit ASCII).
	//
	// DIGIT = %x30-39; according to RFC 5234 (7-Bit ASCII).
	//
	// <S> = *1 ( “*” ); optional separator
	//
	// An example for a valid Evse Pool ID is “IT*123*P456*AB789” with :
	//
	// “IT” indicating Italy,
	//
	// “123” representing a particular Spot Operator,
	//
	// “P” indicating the Pool, and
	//
	// “456*AB789” representing one of its POOL.
	//
	// Note
	//
	// In contrast to the eMA ID, no check digit is specified for the Evse Pool ID in this document. Alpha characters SHALL be interpreted case insensitively. emi³ strongly recommends that implementations SHOULD - use the separator between Country Code and Spot Operator ID - use the separator between Spot Operator ID and ID type
	// This leads to the following regular expression:
	//
	// `([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?P[A-Za-z0-9\*]{1,30})`
	//
	// This regular expression is similar to that of the ISO EvseIDType but E is replaced with P to indicate a pool.
	ChargingPoolID *string `json:"ChargingPoolID,omitempty"`

	// ChargingStationId The ID that identifies the charging station.
	ChargingStationId *string `json:"ChargingStationId,omitempty"`

	// ChargingStationImage URL that redirect to an online image of the related EVSEID
	ChargingStationImage *string `json:"ChargingStationImage,omitempty"`

	// ChargingStationLocationReference Inform the EV driver where the ChargingPoint could be accessed.
	ChargingStationLocationReference *[]InfoTextType `json:"ChargingStationLocationReference,omitempty"`

	// ChargingStationNames Name of the charging station
	ChargingStationNames []InfoTextType `json:"ChargingStationNames"`

	// ClearinghouseID Identification of the corresponding clearing house in the event that roaming between different clearing houses `MUST` be processed in the future.
	ClearinghouseID *string `json:"ClearinghouseID,omitempty"`

	// DynamicInfoAvailable Values: true / false / auto This attribute indicates whether a CPO provides (dynamic) EVSE Status info in addition to the (static) EVSE Data for this EVSERecord. Value auto is set to true by Hubject if the operator offers Hubject EVSEStatus data.
	DynamicInfoAvailable EvseDataRecordDynamicInfoAvailable `json:"DynamicInfoAvailable"`

	// DynamicPowerLevel Informs is able to deliver different power outputs.
	DynamicPowerLevel *bool `json:"DynamicPowerLevel,omitempty"`

	// EnergySource List of energy source that the charging station uses to supply electric energy.
	EnergySource *[]struct {
		// Energy | Option | Description |
		// | Solar | Energy coming from Solar radiation |
		// | Wind | Energy produced by wind |
		// | HydroPower | Energy produced by the movement of water |
		// | GeothermalEnergy | Energy coming from the sub-surface of the earth |
		// | Biomass | Energy produced using plant or animal material as fuel |
		// | Coal | Energy produced using coal as fuel |
		// | NuclearEnergy | Energy being produced by nuclear fission |
		// | Petroleum | Energy produced by using Petroleum as fuel |
		// | NaturalGas | Energy produced using Natural Gas as fuel |
		Energy *EvseDataRecordEnergySourceEnergy `json:"Energy,omitempty"`

		// Percentage Percentage of EnergyType being used by the charging stations
		Percentage *int `json:"Percentage,omitempty"`
	} `json:"EnergySource,omitempty"`
	EnvironmentalImpact *struct {
		// CO2Emission Total CO2 emited by the energy source being used by this charging station to supply energy to EV. Units are in g/kWh
		CO2Emission *float32 `json:"CO2Emission,omitempty"`

		// NuclearWaste Total NuclearWaste emited by the energy source being used by this charging station to supply energy to EV. Units are in g/kWh
		NuclearWaste *float32 `json:"NuclearWaste,omitempty"`
	} `json:"EnvironmentalImpact,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// GeoChargngPointEntrance Important
	//
	// __One of the following three options `MUST` be provided__
	GeoChargngPointEntrance *GeoCoordinates `json:"GeoChargngPointEntrance,omitempty"`

	// GeoCoordinates Important
	//
	// __One of the following three options `MUST` be provided__
	GeoCoordinates GeoCoordinates `json:"GeoCoordinates"`

	// HardwareManufacturer Name of the charging point manufacturer
	HardwareManufacturer *string `json:"HardwareManufacturer,omitempty"`

	// HotlinePhoneNumber `^\+[0-9]{5,15}$`
	// The expression validates the string as a telephone number starting with “+” and containing only numbers.
	//
	// Example: “+0305132787”
	HotlinePhoneNumber string `json:"HotlinePhoneNumber"`

	// HubOperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	HubOperatorID *OperatorIDType `json:"HubOperatorID,omitempty"`

	// IsHubjectCompatible Is eRoaming via intercharge at this charging station possible? If set to "false" the charge spot will not be started/stopped remotely via Hubject.
	IsHubjectCompatible bool `json:"IsHubjectCompatible"`

	// IsOpen24Hours Set in case the charging spot is open 24 hours.
	IsOpen24Hours bool `json:"IsOpen24Hours"`

	// MaxCapacity This field is used if the EVSE has a limited capacity (e.g. built-in battery). Values must be given in kWh.
	MaxCapacity *int `json:"MaxCapacity,omitempty"`

	// OpeningTimes Opening time in case that the charging station cannot be accessed around the clock.
	OpeningTimes *[]OpeningTimes `json:"OpeningTimes,omitempty"`

	// PaymentOptions List of payment options that are supported.
	PaymentOptions []EvseDataRecordPaymentOptions `json:"PaymentOptions"`

	// Plugs List of plugs that are supported.
	Plugs []EvseDataRecordPlugs `json:"Plugs"`

	// RenewableEnergy If the Charging Station provides only renewable energy then the value `MUST` be ”true”, if it use grey energy then value `MUST` be “false”.
	RenewableEnergy bool `json:"RenewableEnergy"`

	// SubOperatorName Name of the Sub Operator owning the Charging Station
	SubOperatorName *string `json:"SubOperatorName,omitempty"`

	// ValueAddedServices List of value added services that are supported.
	ValueAddedServices []EvseDataRecordValueAddedServices `json:"ValueAddedServices"`

	// DeltaType In case that the operation “PullEvseData” is performed with the parameter “LastCall”, Hubject assigns this attribute to every response EVSE record in order to return the changes compared to the last call.
	DeltaType *EvseDataRecordDeltaType `json:"deltaType,omitempty"`

	// LastUpdate The attribute indicates the date and time of the last update of the record. Hubject assigns this attribute to every response EVSE record.
	LastUpdate *time.Time `json:"lastUpdate,omitempty"`
}

// EvseDataRecordAccessibility Specifies how the charging station can be accessed.
//
// | Option | Description |
// | ------ | ----------- |
// | Free publicly accessible | EV Driver can reach the charging point without paying a fee, e.g. street, free public place, free parking lot, etc. |
// | Restricted access | EV Driver needs permission to reach the charging point, e.g. Campus, building complex, etc. |
// | Paying publicly accessible | EV Driver needs to pay a fee in order to reach the charging point, e.g. payable parking garage, etc. |
// | Test Station | Station is just for testing purposes. Access may be restricted. |
type EvseDataRecordAccessibility string

// EvseDataRecordAccessibilityLocation | Option | Description |
// | ------ | ----------- |
// | OnStreet | The charging station is located on the street|
// | ParkingLot | The Charging Point is located inside a Parking Lot|
// | ParkingGarage | The Charging Point is located inside a Parking Garage|
// | UndergroundParkingGarage | The Charging Point is located inside an Underground Parking Garage |
type EvseDataRecordAccessibilityLocation string

// EvseDataRecordAuthenticationModes | Option | Description |
// | NFC RFID Classic | Defined authentication. |
// | NFC RFID DESFire | Defined authentication. |
// | PnC | ISO/IEC 15118. |
// | REMOTE | App, QR-Code, Phone. |
// | Direct Payment | Remote use via direct payment. E.g. intercharge direct |
// | No Authentication Required | Not Authentication Method Required |
type EvseDataRecordAuthenticationModes string

// EvseDataRecordCalibrationLawDataAvailability | Option | Description |
// | Local | Calibration law data is shown at the charging station. |
// | External | Calibration law data is provided externaly. |
// | Not Available | Calibration law data is not provided. |
type EvseDataRecordCalibrationLawDataAvailability string

// EvseDataRecordDynamicInfoAvailable Values: true / false / auto This attribute indicates whether a CPO provides (dynamic) EVSE Status info in addition to the (static) EVSE Data for this EVSERecord. Value auto is set to true by Hubject if the operator offers Hubject EVSEStatus data.
type EvseDataRecordDynamicInfoAvailable string

// EvseDataRecordEnergySourceEnergy | Option | Description |
// | Solar | Energy coming from Solar radiation |
// | Wind | Energy produced by wind |
// | HydroPower | Energy produced by the movement of water |
// | GeothermalEnergy | Energy coming from the sub-surface of the earth |
// | Biomass | Energy produced using plant or animal material as fuel |
// | Coal | Energy produced using coal as fuel |
// | NuclearEnergy | Energy being produced by nuclear fission |
// | Petroleum | Energy produced by using Petroleum as fuel |
// | NaturalGas | Energy produced using Natural Gas as fuel |
type EvseDataRecordEnergySourceEnergy string

// EvseDataRecordPaymentOptions | Option | Description |
// | ------ | ----------- |
// | No payment | Free. |
// | Direct | e. g. Cash, Card, SMS, ... |
// | Contract | i. e. Subscription  |
//
// # Note
//
// `No Payment` can not be combined with other payment option
type EvseDataRecordPaymentOptions string

// EvseDataRecordPlugs | Option | Description |
// |Small Paddle Inductive | Defined plug type. |
// | Large Paddle Inductive | Defined plug type.|
// | AVCON Connector | Defined plug type.|
// | Tesla Connector | Defined plug type.|
// | NEMA 5-20 | Defined plug type.|
// | Type E French Standard | CEE 7/5. |
// | Type F Schuko | CEE 7/4. |
// | Type G British Standard | BS 1363. |
// | Type J Swiss Standard | SEV 1011. |
// | Type 1 Connector (Cable Attached) | Cable attached to IEC 62196-1 type 1, SAE J1772 connector. |
// | Type 2 Outlet | IEC 62196-1 type 2. |
// | Type 2 Connector (Cable Attached) | Cable attached to IEC 62196-1 type 2 connector. |
// | Type 3 Outlet | IEC 62196-1 type 3. |
// | IEC 60309 Single Phase | IEC 60309. |
// | IEC 60309 Three Phase | IEC 60309. |
// | CCS Combo 2 Plug (Cable Attached) | IEC 62196-3 CDV DC Combined Charging Connector DIN SPEC 70121 refers to ISO / IEC 15118-1 DIS, -2 DIS and 15118-3. |
// | CCS Combo 1 Plug (Cable Attached) | IEC 62196-3 CDV DC Combined Charging Connector with IEC 62196-1 type 2 SAE J1772 connector. |
// | CHAdeMO | DC CHAdeMO Connector. |
type EvseDataRecordPlugs string

// EvseDataRecordValueAddedServices | Option | Description |
// | ------ | ----------- |
// | Reservation | Can an EV driver reserve the charging sport via remote services? |
// | DynamicPricing | Does the EVSE ID support dynamic pricing? |
// | ParkingSensors | Is dynamic status info on the parking area in front of the EVSE-ID available? |
// | MaximumPowerCharging | Does the EVSE-ID offer a dynamic maximum power charging? |
// | PredictiveChargePointUsage | Is predictive charge Point usage info available for the EVSE-ID? |
// | ChargingPlans | Does the EVSE-ID offer charging plans, e.g. As described in ISO15118-2? |
// | RoofProvided | Indicates if the charging station is under a roof |
// | None | There are no value-added services available. |
type EvseDataRecordValueAddedServices string

// EvseDataRecordDeltaType In case that the operation “PullEvseData” is performed with the parameter “LastCall”, Hubject assigns this attribute to every response EVSE record in order to return the changes compared to the last call.
type EvseDataRecordDeltaType string

// EvseID The ID that identifies the charging spot.
//
// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
//
// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
//
// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
//
// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
//
// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
//
// Example DIN: “+49*810*000*438”
type EvseID = string

// EvseStatusRecord EvseStatus list
type EvseStatusRecord = []struct {
	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// EvseStatus | Option | Description |
	// | ------ | ----------- |
	// | Available | Charging Spot is available for charging. |
	// | Reserved | Charging Spot is reserved and not available for charging. |
	// | Occupied | Charging Spot is busy. |
	// | OutOfService | Charging Spot is out of service and not available for charging. |
	// | EvseNotFound | The requested EvseID and EVSE status does not exist within the Hubject database. |
	// | Unknown | No status information available. |
	EvseStatus EvseStatusRecordEvseStatus `json:"EvseStatus"`
}

// EvseStatusRecordEvseStatus | Option | Description |
// | ------ | ----------- |
// | Available | Charging Spot is available for charging. |
// | Reserved | Charging Spot is reserved and not available for charging. |
// | Occupied | Charging Spot is busy. |
// | OutOfService | Charging Spot is out of service and not available for charging. |
// | EvseNotFound | The requested EvseID and EVSE status does not exist within the Hubject database. |
// | Unknown | No status information available. |
type EvseStatusRecordEvseStatus string

// GeoCoordinates Important
//
// __One of the following three options `MUST` be provided__
type GeoCoordinates struct {
	// DecimalDegree Geocoordinates using DecimalDegree Structure
	DecimalDegree *DecimalDegreeType `json:"DecimalDegree,omitempty"`

	// DegreeMinuteSeconds Geocoordinates using DegreeMinutesSeconds Structure
	DegreeMinuteSeconds *DegreeMinuteSecondsType `json:"DegreeMinuteSeconds,omitempty"`

	// Google Geocoordinates using Google Structure
	// Based on WGS84
	Google *GoogleType `json:"Google,omitempty"`
}

// GoogleType Geocoordinates using Google Structure
// Based on WGS84
type GoogleType struct {
	// Coordinates A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^-?1?\d{1,2}\.\d{1,6}\s*\,?\s*-?1?\d{1,2}\.\d{1,6}$`
	// The expression validates the string as geo coordinates with respect to the Google standard. The string contains latitude and longitude (in this sequence) separated by a space.
	//
	// Example: “47.662249 9.360922”
	Coordinates string `json:"Coordinates"`
}

// Identification Authentication data
//
// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
type Identification struct {
	// PlugAndChargeIdentification Authentication required for Plug&Charge (EMAID/EVCOID)
	PlugAndChargeIdentification *PlugAndChargeIdentification `json:"PlugAndChargeIdentification,omitempty"`
	QRCodeIdentification        *QRCodeIdentification        `json:"QRCodeIdentification,omitempty"`

	// RFIDIdentification Authentication data details. The data structure differs depending on the authentication technology
	RFIDIdentification *RFIDIdentification `json:"RFIDIdentification,omitempty"`

	// RFIDMifareFamilyIdentification Authentication data details. The data structure differs depending on the authentication technology
	RFIDMifareFamilyIdentification *RFIDMifareFamilyIdentification `json:"RFIDMifareFamilyIdentification,omitempty"`

	// RemoteIdentification Authentication data details. The data structure differs depending on the authentication technology
	RemoteIdentification *RemoteIdentification `json:"RemoteIdentification,omitempty"`
}

// InfoTextType defines model for InfoTextType.
type InfoTextType struct {
	// Lang `^[a-z]{2,3}(?:-[A-Z]{2,3}(?:-[a-zA-Z]{4})?)?(?:-x-[a-zA-Z0-9]{1,8})?$`
	//
	// The language in which the additional info text is provided
	//
	// The expression validates the string as a language code as per ISO-639-1 or ISO-639-2/T
	//
	// The LanguageCodeType is used in the AdditionalInfo field, which is part of the EvseDataRecordType.
	Lang string `json:"lang"`

	// Value The Additional Info text
	Value string `json:"value"`
}

// OpeningTimes defines model for OpeningTimes.
type OpeningTimes struct {
	// Period The starting and end time for pricing product applicability in the specified period
	Period []struct {
		// Begin The opening time
		Begin string `json:"begin"`

		// End The closing time
		End string `json:"end"`
	} `json:"Period"`

	// On Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
	On OpeningTimesOn `json:"on"`
}

// OpeningTimesOn Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
type OpeningTimesOn string

// OperatorEvseDataType defines model for OperatorEvseDataType.
type OperatorEvseDataType struct {
	// EvseDataRecord EVSE entries
	EvseDataRecord []EvseDataRecord `json:"EvseDataRecord"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID OperatorIDType `json:"OperatorID"`

	// OperatorName Free text for operator
	OperatorName string `json:"OperatorName"`
}

// OperatorEvseStatus Indicates the Eves status
type OperatorEvseStatus struct {
	// EvseStatusRecord EvseStatus list
	EvseStatusRecord EvseStatusRecord `json:"EvseStatusRecord"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID OperatorIDType `json:"OperatorID"`

	// OperatorName Free text for operator
	OperatorName *string `json:"OperatorName,omitempty"`
}

// OperatorIDType A string that MUST be valid with respect to the following regular expression: ISO | DIN
//
// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
//
// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
//
// Examples ISO: “DE*A36”, “DEA36”
//
// Example DIN: “+49*536”
type OperatorIDType = string

// PlugAndChargeIdentification Authentication required for Plug&Charge (EMAID/EVCOID)
type PlugAndChargeIdentification struct {
	// EvcoID A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// ^(([A-Za-z]{2}\-?[A-Za-z0-9]{3}\-?C[A-Za-z0-9]{8}\-?[\d|A-Za-z])|([A-Za-z]{2}[\*|\-]?[A-Za-z0-9]{3}[\*|\-]?[A-Za-z0-9]{6}[\*|\-]?[\d|X]))$
	// The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.
	//
	// In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.
	//
	// Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”
	//
	// Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
	EvcoID EvcoID `json:"EvcoID"`
}

// PricingProductDataRecord defines model for PricingProductDataRecord.
type PricingProductDataRecord struct {
	// AdditionalReferences A list of additional reference units and their respective prices
	AdditionalReferences *[]struct {
		// AdditionalReference Additional pricing components to be considered in addition to the base pricing
		//
		// | Option | Description |
		// | ------ | ----------- |
		// | START FEE | Can be used in case a fixed fee is charged for the initiation of the charging session. This is a fee charged on top of the main base price defined in the field "PricePerReferenceUnit" for any particular pricing product. |
		// | FIXED FEE | Can be used if a single price is charged irrespective of charging duration or energy consumption (for instance if all sessions are to be charged a single fixed fee). When used, the value set in the field "PricePerReferenceUnit" for the main base price of respective pricing product SHOULD be set to zero. |
		// | PARKING FEE | Can be used in case sessions are to be charged for both parking and charging. When used, it needs to be specified in the corresponding service offer on the HBS Portal when parking applies (e.g. from session start to charging start and charging end to session end or for the entire session duration, or x-minutes after charging end, etc) |
		// | MINIMUM FEE | Can be used in case there is a minimum fee to be paid for all charging sessions. When used, this implies that the eventual price to be paid cannot be less than this minimum fee but can however be a price above/greater than the minimum fee. |
		// | MAXIMUM FEE | Can be used in case there is a maximum fee to be charged for all charging sessions. When used, this implies that the eventual price to be paid cannot be more than this maximum fee but can however be a price below/lower than the maximum fee. |
		AdditionalReference PricingProductDataRecordAdditionalReferencesAdditionalReference `json:"AdditionalReference"`

		// AdditionalReferenceUnit Default Reference Unit in time or kWh
		//
		// | Option | Description |
		// | ------ | ----------- |
		// | HOUR | Defined Reference Unit Type |
		// | KILOWATT_HOUR | Defined Reference Unit Type |
		// | MINUTE | Defined Reference Unit Type |
		AdditionalReferenceUnit ReferenceUnit `json:"AdditionalReferenceUnit"`

		// PricePerAdditionalReferenceUnit A price in the given currency
		PricePerAdditionalReferenceUnit float32 `json:"PricePerAdditionalReferenceUnit"`
	} `json:"AdditionalReferences,omitempty"`

	// IsValid24hours Set to TRUE if the respective pricing product is applicable 24 hours a day.
	// If FALSE, the respective applicability times `SHOULD` be provided in the field “ProductAvailabilityTimes”.
	IsValid24hours bool `json:"IsValid24hours"`

	// MaximumProductChargingPower A value in kWh
	MaximumProductChargingPower float32 `json:"MaximumProductChargingPower"`

	// PricePerReferenceUnit A price per reference unit
	PricePerReferenceUnit float32 `json:"PricePerReferenceUnit"`

	// ProductAvailabilityTimes A list indicating when the pricing product is applicable
	ProductAvailabilityTimes []struct {
		Periods []struct {
			// Begin The opening time
			Begin string `json:"begin"`

			// End The closing time
			End string `json:"end"`
		} `json:"Periods"`

		// On Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
		On PricingProductDataRecordProductAvailabilityTimesOn `json:"on"`
	} `json:"ProductAvailabilityTimes"`

	// ProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	ProductID ProductID `json:"ProductID"`

	// ProductPriceCurrency The ProductPriceCurrencyType allows for the list of active codes of the official ISO 4217 currency names.
	//
	// For the full list of active codes of the official ISO 4217 currencies, see: [https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)
	//
	// Examples:
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | EUR | Euro |
	// | CHF | Swiss franc |
	// | CAD | Canadian Dollar |
	// | GBP | Pound sterling
	ProductPriceCurrency CurrencyID `json:"ProductPriceCurrency"`

	// ReferenceUnit Default Reference Unit in time or kWh
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | HOUR | Defined Reference Unit Type |
	// | KILOWATT_HOUR | Defined Reference Unit Type |
	// | MINUTE | Defined Reference Unit Type |
	ReferenceUnit ReferenceUnit `json:"ReferenceUnit"`
}

// PricingProductDataRecordAdditionalReferencesAdditionalReference Additional pricing components to be considered in addition to the base pricing
//
// | Option | Description |
// | ------ | ----------- |
// | START FEE | Can be used in case a fixed fee is charged for the initiation of the charging session. This is a fee charged on top of the main base price defined in the field "PricePerReferenceUnit" for any particular pricing product. |
// | FIXED FEE | Can be used if a single price is charged irrespective of charging duration or energy consumption (for instance if all sessions are to be charged a single fixed fee). When used, the value set in the field "PricePerReferenceUnit" for the main base price of respective pricing product SHOULD be set to zero. |
// | PARKING FEE | Can be used in case sessions are to be charged for both parking and charging. When used, it needs to be specified in the corresponding service offer on the HBS Portal when parking applies (e.g. from session start to charging start and charging end to session end or for the entire session duration, or x-minutes after charging end, etc) |
// | MINIMUM FEE | Can be used in case there is a minimum fee to be paid for all charging sessions. When used, this implies that the eventual price to be paid cannot be less than this minimum fee but can however be a price above/greater than the minimum fee. |
// | MAXIMUM FEE | Can be used in case there is a maximum fee to be charged for all charging sessions. When used, this implies that the eventual price to be paid cannot be more than this maximum fee but can however be a price below/lower than the maximum fee. |
type PricingProductDataRecordAdditionalReferencesAdditionalReference string

// PricingProductDataRecordProductAvailabilityTimesOn Day values to be used in specifying periods on which the product is available. Workdays = Monday – Friday, Weekend = Saturday – Sunday
type PricingProductDataRecordProductAvailabilityTimesOn string

// ProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
// | Option | Description |
// |--------|-------------|
// | Standard Price | Standard Price |
// | AC1 | Product for AC 1 Phase charging |
// | AC3 | Product for AC 3 Phase charging |
// | DC | Product for DC charging |
// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
type ProductID = string

// ProviderIDAsterisk The ProviderID is defined by Hubject and is used to identify the EMP
//
// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
//
// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
//
// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
//
// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
//
// Examples ISO: “DE8EO”, “DE-8EO”
//
// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
//
//	In case the data is to be made available for all EMPs (e.g. for Offer-to-All prices), the asterix character (*) can be set as the value in this field.
type ProviderIDAsterisk = string

// ProviderIDType The ProviderID is defined by Hubject and is used to identify the EMP
//
// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
//
// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
//
// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
//
// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
//
// Examples ISO: “DE8EO”, “DE-8EO”
//
// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
type ProviderIDType = string

// QRCodeIdentification defines model for QRCodeIdentification.
type QRCodeIdentification struct {
	// EvcoID A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// ^(([A-Za-z]{2}\-?[A-Za-z0-9]{3}\-?C[A-Za-z0-9]{8}\-?[\d|A-Za-z])|([A-Za-z]{2}[\*|\-]?[A-Za-z0-9]{3}[\*|\-]?[A-Za-z0-9]{6}[\*|\-]?[\d|X]))$
	// The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.
	//
	// In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.
	//
	// Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”
	//
	// Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
	EvcoID    EvcoID `json:"EvcoID"`
	HashedPIN *struct {
		// Function Function that was used to generate the hash value.
		Function       QRCodeIdentificationHashedPINFunction `json:"Function"`
		LegacyHashData *struct {
			// Function Function used for hashing of the PIN at the partner.
			Function QRCodeIdentificationHashedPINLegacyHashDataFunction `json:"Function"`

			// Salt The salt value used by the partner for hashing the PIN.
			Salt *string `json:"Salt,omitempty"`

			// Value PIN hash at the partner.
			Value *string `json:"Value,omitempty"`
		} `json:"LegacyHashData,omitempty"`

		// Value Hash value created by partner
		//
		// The expression validates the string as a hash function result value with a length between 10 and 100 characters
		//
		// Example: “a5ghdhf73h”
		Value string `json:"Value"`
	} `json:"HashedPIN,omitempty"`
	PIN *string `json:"PIN,omitempty"`
}

// QRCodeIdentificationHashedPINFunction Function that was used to generate the hash value.
type QRCodeIdentificationHashedPINFunction string

// QRCodeIdentificationHashedPINLegacyHashDataFunction Function used for hashing of the PIN at the partner.
type QRCodeIdentificationHashedPINLegacyHashDataFunction string

// RFIDIdentification Authentication data details. The data structure differs depending on the authentication technology
type RFIDIdentification struct {
	// EvcoID A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// ^(([A-Za-z]{2}\-?[A-Za-z0-9]{3}\-?C[A-Za-z0-9]{8}\-?[\d|A-Za-z])|([A-Za-z]{2}[\*|\-]?[A-Za-z0-9]{3}[\*|\-]?[A-Za-z0-9]{6}[\*|\-]?[\d|X]))$
	// The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.
	//
	// In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.
	//
	// Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”
	//
	// Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
	EvcoID *EvcoID `json:"EvcoID,omitempty"`

	// ExpiryDate Until when this card is valid. Should not be set if card does not have an expiration
	ExpiryDate *string `json:"ExpiryDate,omitempty"`

	// PrintedNumber A number printed on a customer’s card for manual authorization (e.q. via a call center)
	PrintedNumber *string `json:"PrintedNumber,omitempty"`

	// RFID Defined RFID Type
	RFID RFIDIdentificationRFID `json:"RFID"`

	// UID Authentication data details. The data structure differs depending on the authentication technology
	//
	// The expression validates the string as a unique RFID with a length of 8, 14 or 20 characters.
	//
	// Examples: “7568290FFF765F”
	UID UID `json:"UID"`
}

// RFIDIdentificationRFID Defined RFID Type
type RFIDIdentificationRFID string

// RFIDMifareFamilyIdentification Authentication data details. The data structure differs depending on the authentication technology
type RFIDMifareFamilyIdentification struct {
	// UID Authentication data details. The data structure differs depending on the authentication technology
	//
	// The expression validates the string as a unique RFID with a length of 8, 14 or 20 characters.
	//
	// Examples: “7568290FFF765F”
	UID UID `json:"UID"`
}

// ReferenceUnit Default Reference Unit in time or kWh
//
// | Option | Description |
// | ------ | ----------- |
// | HOUR | Defined Reference Unit Type |
// | KILOWATT_HOUR | Defined Reference Unit Type |
// | MINUTE | Defined Reference Unit Type |
type ReferenceUnit = string

// RemoteIdentification Authentication data details. The data structure differs depending on the authentication technology
type RemoteIdentification struct {
	// EvcoID A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// ^(([A-Za-z]{2}\-?[A-Za-z0-9]{3}\-?C[A-Za-z0-9]{8}\-?[\d|A-Za-z])|([A-Za-z]{2}[\*|\-]?[A-Za-z0-9]{3}[\*|\-]?[A-Za-z0-9]{6}[\*|\-]?[\d|X]))$
	// The expression validates the string as EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvcoID is provided corresponding to ISO, the instance part MUST be eight characters long and MUST be provided with a prepended “C”. The optional separating character MUST be “-“.
	//
	// In case the EvcoID is provided corresponding to DIN, the instance part MUST be six characters long. The optional separating character can either be “*” or “-“.
	//
	// Examples ISO: “DE-8EO-CAet5e4XY-3”, “DE8EOCAet5e43X1”
	//
	// Examples DIN: “DE*8EO*Aet5e4*3”, “DE-8EO-Aet5e4-3”, “DE8EOAet5e43”
	EvcoID EvcoID `json:"EvcoID"`
}

// SessionID The Hubject SessionID that identifies the process
//
// A string that `MUST` be valid with respect to the following regular expression:
//
// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
//
// The expression validates the string as a GUID.
//
// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
type SessionID = string

// StatusCode The structure consists of a defined code, an optional functional description of the status, and optional additional information. It can be used e.g. to send error details or detailed reasons for a certain process or system behavior. The optional AdditionalInfo field can be used in order to provide further individual (non-standardized) information.
type StatusCode struct {
	// AdditionalInfo More information can be provided here
	AdditionalInfo *string `json:"AdditionalInfo,omitempty"`

	// Code | Option | Description | Area of Usage |
	// | -------|-------------|---------------|
	// | 000 | Success. | General codes |
	// | 001 | Hubject system error. | Internal system codes |
	// | 002 | Hubject database error. |Internal system codes|
	// | 009 |Data transaction error. | Internal system codes|
	// |017 |Unauthorized Access. |Internal system codes |
	// |018 |Inconsistent EvseID. |Internal system codes |
	// |019 |Inconsistent EvcoID. |Internal system codes |
	// |021 |System error. |General codes |
	// |022 |Data error. |General codes |
	// |101 |QR Code Authentication failed – Invalid Credentials. |Authentication codes |
	// |102 |RFID Authentication failed – invalid UID. |Authentication codes |
	// |103 |RFID Authentication failed – card not readable. |Authentication codes |
	// |105 |PLC Authentication failed - invalid EvcoID. |Authentication codes |
	// |106 |No positive authentication response. |Authentication codes / Internal system codes |
	// |110 |QR Code App Authentication failed – time out error. |Authentication codes |
	// |120 |PLC (ISO/ IEC 15118) Authentication failed – invalid underlying EvcoID. |Authentication codes |
	// |121 |PLC (ISO/ IEC 15118) Authentication failed – invalid certificate. |Authentication codes |
	// |122 |PLC (ISO/ IEC 15118) Authentication failed – time out error. |Authentication codes |
	// |200 |EvcoID locked. |Authentication codes |
	// |210 |No valid contract. |Session codes |
	// |300 |Partner not found. |Session codes |
	// |310 |Partner did not respond. |Session codes |
	// |320 |Service not available. |Session codes |
	// |400 |Session is invalid. |Session codes |
	// |501 |Communication to EVSE failed. |EVSE codes |
	// |510 |No EV connected to EVSE. |EVSE codes |
	// |601 |EVSE already reserved. |EVSE codes |
	// |602 |EVSE already in use/ wrong token. |EVSE codes |
	// |603 |Unknown EVSE ID. |EVSE codes |
	// |604 |EVSE ID is not Hubject compatible. |EVSE codes |
	// |700 |EVSE out of service. |EVSE codes |
	Code string `json:"Code"`

	// Description description
	Description *string `json:"Description,omitempty"`
}

// UID Authentication data details. The data structure differs depending on the authentication technology
//
// The expression validates the string as a unique RFID with a length of 8, 14 or 20 characters.
//
// Examples: “7568290FFF765F”
type UID = string

// ERoamingAcknowledgmen The acknowledgement is a message that is sent in response to several requests.
//
// * To `SEND` and `RECEIVE`
// * Implementation: `MANDATORY`
type ERoamingAcknowledgmen struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// Result If result is true, the message was received and the respective operation was performed successfully.
	//
	// If result is false, the message was received and the respective operation was not performed successfully.
	Result bool `json:"Result"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// StatusCode The structure consists of a defined code, an optional functional description of the status, and optional additional information. It can be used e.g. to send error details or detailed reasons for a certain process or system behavior. The optional AdditionalInfo field can be used in order to provide further individual (non-standardized) information.
	StatusCode StatusCode `json:"StatusCode"`
}

// ERoamingAuthorizationStart Note:
//   - To `RECEIVE`
//   - Implementation: `MANDATORY`
//
// eRoamingAuthorizationStart is a message that authorizes a user to charge a car. NOTE: This message describes the response which has to be receive in response to the eRoamingAuthorizeStart.
type ERoamingAuthorizationStart struct {
	// AuthorizationStatus Information specifying whether the user is authorized to charge or not.
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | Authorized | User is authorized |
	// | NotAuthorized | User is not authorized |
	AuthorizationStatus ERoamingAuthorizationStartAuthorizationStatus `json:"AuthorizationStatus"`

	// AuthorizationStopIdentifications A list of Identification data that is authorized to stop the charging process.
	AuthorizationStopIdentifications *[]struct {
		// PlugAndChargeIdentification Authentication required for Plug&Charge (EMAID/EVCOID)
		PlugAndChargeIdentification *PlugAndChargeIdentification `json:"PlugAndChargeIdentification,omitempty"`
		QRCodeIdentification        *QRCodeIdentification        `json:"QRCodeIdentification,omitempty"`

		// RFIDIdentification Authentication data details. The data structure differs depending on the authentication technology
		RFIDIdentification *RFIDIdentification `json:"RFIDIdentification,omitempty"`

		// RFIDMifareFamilyIdentification Authentication data details. The data structure differs depending on the authentication technology
		RFIDMifareFamilyIdentification *RFIDMifareFamilyIdentification `json:"RFIDMifareFamilyIdentification,omitempty"`

		// RemoteIdentification Authentication data details. The data structure differs depending on the authentication technology
		RemoteIdentification *RemoteIdentification `json:"RemoteIdentification,omitempty"`
	} `json:"AuthorizationStopIdentifications,omitempty"`

	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID *ProviderIDType `json:"ProviderID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// StatusCode The structure consists of a defined code, an optional functional description of the status, and optional additional information. It can be used e.g. to send error details or detailed reasons for a certain process or system behavior. The optional AdditionalInfo field can be used in order to provide further individual (non-standardized) information.
	StatusCode StatusCode `json:"StatusCode"`
}

// ERoamingAuthorizationStartAuthorizationStatus Information specifying whether the user is authorized to charge or not.
//
// | Option | Description |
// | ------ | ----------- |
// | Authorized | User is authorized |
// | NotAuthorized | User is not authorized |
type ERoamingAuthorizationStartAuthorizationStatus string

// ERoamingAuthorizationStop Note:
//   - To `RECEIVE`
//   - Implementation: `OPTIONAL`
//
// eRoamingAuthorizeStop is a message to request an authorization for stopping a charging process.
//
// Note:
//
// This message describes the response which has to be received in return to the eRoamingAuthorizeStop request.
type ERoamingAuthorizationStop struct {
	// AuthorizationStatus Information specifying whether the user is authorized to charge or not.
	//
	// | Option | Description |
	// | ------ | ----------- |
	// | Authorized | User is authorized |
	// | NotAuthorized | User is not authorized |
	AuthorizationStatus ERoamingAuthorizationStopAuthorizationStatus `json:"AuthorizationStatus"`

	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID *ProviderIDType `json:"ProviderID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// StatusCode The structure consists of a defined code, an optional functional description of the status, and optional additional information. It can be used e.g. to send error details or detailed reasons for a certain process or system behavior. The optional AdditionalInfo field can be used in order to provide further individual (non-standardized) information.
	StatusCode StatusCode `json:"StatusCode"`
}

// ERoamingAuthorizationStopAuthorizationStatus Information specifying whether the user is authorized to charge or not.
//
// | Option | Description |
// | ------ | ----------- |
// | Authorized | User is authorized |
// | NotAuthorized | User is not authorized |
type ERoamingAuthorizationStopAuthorizationStatus string

// ERoamingAuthorizeRemoteReservationStart defines model for eRoamingAuthorizeRemoteReservationStart.
type ERoamingAuthorizeRemoteReservationStart struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation. Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// Duration Duration of reservation in minutes
	Duration *int64 `json:"Duration,omitempty"`

	// EMPPartnerSessionId Optional field containing the session id assigned by an EMP to the related operation. Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionId *string `json:"EMPPartnerSessionId,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification Identification `json:"Identification"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID ProviderIDType `json:"ProviderID"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`
}

// ERoamingAuthorizeRemoteReservationStop defines model for eRoamingAuthorizeRemoteReservationStop.
type ERoamingAuthorizeRemoteReservationStop struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation. Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionId Optional field containing the session id assigned by an EMP to the related operation. Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionId *string `json:"EMPPartnerSessionId,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID ProviderIDType `json:"ProviderID"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID SessionID `json:"SessionID"`
}

// ERoamingAuthorizeRemoteStart defines model for eRoamingAuthorizeRemoteStart.
type ERoamingAuthorizeRemoteStart struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification Identification `json:"Identification"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID ProviderIDType `json:"ProviderID"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID SessionID `json:"SessionID"`
}

// ERoamingAuthorizeRemoteStop defines model for eRoamingAuthorizeRemoteStop.
type ERoamingAuthorizeRemoteStop struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	ProviderID ProviderIDType `json:"ProviderID"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID SessionID `json:"SessionID"`
}

// ERoamingAuthorizeStart Best Practices:
// * The EVSE ID is optional for this message which is e.g. defined after the RFID authorization at a charge point. If the Evse ID can be provided, we recommend to include the EVSE ID in this message; it will help for support matters.
// * If an authorization process could not successfully be executed, please set an error code by refering to the error code list mentioned in the OICP document.
type ERoamingAuthorizeStart struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification Identification `json:"Identification"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID OperatorIDType `json:"OperatorID"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`
}

// ERoamingAuthorizeStop defines model for eRoamingAuthorizeStop.
type ERoamingAuthorizeStop struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification Identification `json:"Identification"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID OperatorIDType `json:"OperatorID"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID SessionID `json:"SessionID"`
}

// ERoamingChargeDetailRecord eRoamingChargeDetailRecord is a message that contains charging process details (e.g. meter values).
type ERoamingChargeDetailRecord struct {
	// CPOPartnerSessionID Optional field containing the session id assigned by the CPO to the related operation.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// CalibrationLawVerificationInfo This field provides additional information which could help directly or indirectly to verify the signed metering value by using respective Transparency Software
	CalibrationLawVerificationInfo *struct {
		// CalibrationLawCertificateID The Calibration Law Compliance ID from respective authority along with the revision and issueing date (Compliance ID : Revision : Date) For eg PTB - X-X-XXXX : V1 : 01Jan2020
		CalibrationLawCertificateID *string `json:"CalibrationLawCertificateID,omitempty"`

		// MeteringSignatureEncodingFormat Encoding format of the metering signature data as well as the version (e.g. EDL40 Mennekes: V1)
		MeteringSignatureEncodingFormat *string `json:"MeteringSignatureEncodingFormat,omitempty"`

		// MeteringSignatureUrl In this field CPO can also provide a url for xml file. This xml file can give the compiled Calibration Law Data information which can be simply added to invoices for Customer of EMP.
		//
		// The information can contain for eg Charging Station Details, Charging Session Date/Time, SignedMeteringValues (Transparency Software format), SignedMeterValuesVerificationInstruction etc.
		MeteringSignatureUrl *string `json:"MeteringSignatureUrl,omitempty"`

		// PublicKey Unique PublicKey for EVSEID can be provided here
		PublicKey *string `json:"PublicKey,omitempty"`

		// SignedMeteringValuesVerificationInstruction Additional information (e.g. instruction on how to use the transparency software)
		SignedMeteringValuesVerificationInstruction *string `json:"SignedMeteringValuesVerificationInstruction,omitempty"`
	} `json:"CalibrationLawVerificationInfo,omitempty"`

	// ChargingEnd The date and time at which the charging process stoped.
	ChargingEnd time.Time `json:"ChargingEnd"`

	// ChargingStart The date and time at which the charging process started.
	ChargingStart time.Time `json:"ChargingStart"`

	// ConsumedEnergy The difference between MeterValueEnd and MeterValueStart in kWh.
	ConsumedEnergy float32 `json:"ConsumedEnergy"`

	// EMPPartnerSessionID Optional field containing the session id assigned by an EMP to the related operation.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID EvseID `json:"EvseID"`

	// HubOperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	HubOperatorID *OperatorIDType `json:"HubOperatorID,omitempty"`

	// HubProviderId The ProviderID is defined by Hubject and is used to identify the EMP
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
	//
	// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
	//
	// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
	//
	// Examples ISO: “DE8EO”, “DE-8EO”
	//
	// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
	HubProviderId *ProviderIDType `json:"HubProviderId,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification Identification `json:"Identification"`

	// MeterValueEnd The ending meter value in kWh.
	MeterValueEnd *float32 `json:"MeterValueEnd,omitempty"`

	// MeterValueInBetween List of meter values that may have been taken in between (kWh).
	MeterValueInBetween *struct {
		MeterValues *[]float32 `json:"meterValues,omitempty"`
	} `json:"MeterValueInBetween,omitempty"`

	// MeterValueStart The starting meter value in kWh.
	MeterValueStart *float32 `json:"MeterValueStart,omitempty"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// SessionEnd The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionEnd time.Time `json:"SessionEnd"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID SessionID `json:"SessionID"`

	// SessionStart The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionStart time.Time `json:"SessionStart"`

	// SignedMeteringValues Metering Signature basically contains all metering signature values (these values should be in Transparency software format) for different status of charging session for eg start, end or progress. In total you can provide maximum 10 metering signature values
	SignedMeteringValues *[]struct {
		// MeteringStatus | Option | Description |
		// | ------ | ----------- |
		// | Start | Metering signature value of the beginning of charging process. |
		// | Progress | An intermediate metering signature value of the charging process. |
		// | End | Metering Signature Value of the end of the charging process. |
		MeteringStatus *ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus `json:"MeteringStatus,omitempty"`

		// SignedMeteringValue Metering signature value (in the Transparency software format)
		//
		// SignedMeteringValue `SHOULD` be always sent in following order
		// 1. SignedMeteringValue for Metering Status “Start”
		// 2. SignedMeteringValue for Metering Status “Progress1”
		// 3. SignedMeteringValue for Metering Status “Progress2”
		// 4. …
		// 5. SignedMeteringValue for Metering Status “Progress8”
		// 6. SignedMeteringValue for Metering Status “End”
		//
		// Note:
		//
		// 1. This field `MUST` be provided when the EVSEID in the ChargeDetailRecord contains the "External" value in the CalibrationLawDataAvailability field.
		// 2. The MeteringSignatureValue format provided `MUST` be supported by the Transparency Software used by the CPO
		SignedMeteringValue *string `json:"SignedMeteringValue,omitempty"`
	} `json:"SignedMeteringValues,omitempty"`
}

// ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus | Option | Description |
// | ------ | ----------- |
// | Start | Metering signature value of the beginning of charging process. |
// | Progress | An intermediate metering signature value of the charging process. |
// | End | Metering Signature Value of the end of the charging process. |
type ERoamingChargeDetailRecordSignedMeteringValuesMeteringStatus string

// ERoamingChargingNotificationEnd A customer of an EMP has fully charged a vehicle at a charging station of a CPO. The charging process was started with an eRoamingAuthorizeStart or an eRoamingAuthorizeRemoteStart operation. The energy flow has ended, but the process has not yet been stopped and the vehicle is blocking the charging station.
//
// The CPO’s backend system MAY send a ChargingNotification of type “End” after the CPO considers the charging of an EV concluded (because no energy is transmitted anymore) in order to inform the EMP that the actual charging (the energy flow) of the vehicle has stopped. The charging process has not yet been stopped by the customer and the session is still active.
//
// The ChargingNotification of type “End” is a message that contains information about the charging end of a session (e.g. ConsumedEnergy, ChargingEnd).
type ERoamingChargingNotificationEnd struct {
	// CPOPartnerSessionID Optional field containing the session ID assigned by the CPO to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// ChargingEnd The date and time at which the charging process stoped.
	ChargingEnd *time.Time `json:"ChargingEnd,omitempty"`

	// ChargingStart The date and time at which the charging process started.
	ChargingStart *time.Time `json:"ChargingStart,omitempty"`

	// ConsumedEnergy The difference between MeterValueEnd and MeterValueStart in kWh.
	ConsumedEnergy *float32 `json:"ConsumedEnergy,omitempty"`

	// EMPPartnerSessionID Optional field containing the session ID assigned by an EMP to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification *Identification `json:"Identification,omitempty"`

	// MeterValueEnd The ending meter value in kWh.
	MeterValueEnd *float32 `json:"MeterValueEnd,omitempty"`

	// MeterValueInBetween List of meter values that may have been taken in between (kWh).
	MeterValueInBetween *struct {
		MeterValues *[]float32 `json:"meterValues,omitempty"`
	} `json:"MeterValueInBetween,omitempty"`

	// MeterValueStart The starting meter value in kWh.
	MeterValueStart *float32 `json:"MeterValueStart,omitempty"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID *OperatorIDType `json:"OperatorID,omitempty"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// PenaltyTimeStart The date and time at which the penalty time start after the grace period.
	PenaltyTimeStart *time.Time `json:"PenaltyTimeStart,omitempty"`

	// SessionEnd The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionEnd *time.Time `json:"SessionEnd,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// SessionStart The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionStart *time.Time `json:"SessionStart,omitempty"`

	// Type The type of ChargingNotification
	Type *ChargingNotificationType `json:"Type,omitempty"`
}

// ERoamingChargingNotificationError A customer of EMP Authorizes the charging session at particular charging station (via any means for eg REFID card, Mobile etc). Due to some errors sometime, it is possible that charging does not start or charging process is abruptly stopped or fluctuations in the charging process. It is really important for Customer as well as EMP to know what exactly is happening at the charging process. This notification eventually helps EMPs well informed about the problem occurred with the charging process. This information can be easily passed onto Customer so that he/she can take appropriate action.
//
// The CPO’s backend system MAY send a ChargingNotification of type “Error” after the CPO gets an information about the error at the charging station. The CPO can transmit one of the ErrorClass defined by Hubject along with the additional information which elaborated the Error. The customer has to take one of the three action EV needs to be charged at some different station, Cables is properly attached or the error is for information only no action required by customer.
//
// The ChargingNotification of type “Error” is a message that contains information about the charging end of a session (e.g. ErrorClass, ErrorAdditionalInfo).
type ERoamingChargingNotificationError struct {
	// CPOPartnerSessionID Optional field containing the session ID assigned by the CPO to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// EMPPartnerSessionID Optional field containing the session ID assigned by an EMP to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// ErrorAdditionalInfo The CPO can put in the additional information about the error
	ErrorAdditionalInfo *string `json:"ErrorAdditionalInfo,omitempty"`

	// ErrorType | Option | Description |
	// | ------ | ----------- |
	// | ConnectorError | Charging process cannot be started or stopped. EV driver needs to check if the the Plug is properly inserted or taken out from socket. |
	// | CriticalError | Charging process stopped abruptly. Reason: Physical check at the station is required. Station cannot be reset online. <br /> Or <br /> Error with the software or hardware of the station locally. <br /> Or <br /> Communication failure with the vehicle. <br /> Or <br /> The error needs to be investigated <br /> Or <br /> Ground Failure |
	ErrorType *ERoamingChargingNotificationErrorErrorType `json:"ErrorType,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification *Identification `json:"Identification,omitempty"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID *OperatorIDType `json:"OperatorID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// Type The type of ChargingNotification
	Type *ChargingNotificationType `json:"Type,omitempty"`
}

// ERoamingChargingNotificationErrorErrorType | Option | Description |
// | ------ | ----------- |
// | ConnectorError | Charging process cannot be started or stopped. EV driver needs to check if the the Plug is properly inserted or taken out from socket. |
// | CriticalError | Charging process stopped abruptly. Reason: Physical check at the station is required. Station cannot be reset online. <br /> Or <br /> Error with the software or hardware of the station locally. <br /> Or <br /> Communication failure with the vehicle. <br /> Or <br /> The error needs to be investigated <br /> Or <br /> Ground Failure |
type ERoamingChargingNotificationErrorErrorType string

// ERoamingChargingNotificationProgress A customer of EMP has started the charging session. Just like as that of regular gasoline stations customer would like to know either how much charging Duration have passed or how much energy is consumed by the EV so far. This information will help Customer to decide if he/she wants to stop the charging session as per their affordability or journey planning.
//
// The CPO’s backend system MAY send a ChargingNotification of type “Progess” after the CPO gets the charging energy or time information from EVSEID. This is required in order to inform the EMP that the progress energy or chargingduration for a perticular charging session.
//
// The ChargingNotification of type “Progress” is a message that contains information about the charging Duration or energy consumed during charging process (e.g. EventOccurred, ChargingDuration, ConsumedEnergyProgress).
type ERoamingChargingNotificationProgress struct {
	// CPOPartnerSessionID Optional field containing the session ID assigned by the CPO to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// ChargingDuration Charging Duration = EventOccurred - Charging Duration. It is a time in millisecond.
	//
	// Either ChargingDuration or ConsumedEnergyProgress should be provided. Both can also be provided with each progress notification.
	ChargingDuration *int `json:"ChargingDuration,omitempty"`

	// ChargingStart The date and time at which the charging process started.
	ChargingStart *time.Time `json:"ChargingStart,omitempty"`

	// ConsumedEnergyProgress This is consumed energy when from Start of charging process till the charging progress notification generated (EventOccurred)
	//
	// Either ChargingDuration or ConsumedEnergyProgress should be provided. Both can also be provided with each progress notification.
	ConsumedEnergyProgress *float32 `json:"ConsumedEnergyProgress,omitempty"`

	// EMPPartnerSessionID Optional field containing the session ID assigned by an EMP to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EventOccurred The date and time at which the charging progress parameters are captured.
	EventOccurred *time.Time `json:"EventOccurred,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification *Identification `json:"Identification,omitempty"`

	// MeterValueInBetween List of meter values that may have been taken in between (kWh).
	MeterValueInBetween *struct {
		MeterValues *[]float32 `json:"meterValues,omitempty"`
	} `json:"MeterValueInBetween,omitempty"`

	// MeterValueStart The starting meter value in kWh.
	MeterValueStart *float32 `json:"MeterValueStart,omitempty"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID *OperatorIDType `json:"OperatorID,omitempty"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// SessionStart The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionStart *time.Time `json:"SessionStart,omitempty"`

	// Type The type of ChargingNotification
	Type *ChargingNotificationType `json:"Type,omitempty"`
}

// ERoamingChargingNotificationStart A customer of EMP Authorizes the charging session at particular charging station (via any means for eg REFID card, Mobile etc). The charging session is authorized by Hubject / CPO system. The authorization of charging process and plugging the cable in EV does not guarantee that energy flow into the Vehicle is initiated. It is really important for for EMP and its end consumer to know if the charging has started.
//
// The CPO’s backend system MAY send a ChargingNotification of type “Start” after the CPO considers the charging of an EV is started (since energy flow have started) in order to inform the EMP that the actual charging (the energy flow) of the vehicle has started.
//
// The ChargingNotification of type “Start” is a message that contains information about the charging start of a session (e.g. ChargingStart).
type ERoamingChargingNotificationStart struct {
	// CPOPartnerSessionID Optional field containing the session ID assigned by the CPO to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// ChargingStart The date and time at which the charging process started.
	ChargingStart *time.Time `json:"ChargingStart,omitempty"`

	// EMPPartnerSessionID Optional field containing the session ID assigned by an EMP to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification *Identification `json:"Identification,omitempty"`

	// MeterValueStart The starting meter value in kWh.
	MeterValueStart *float32 `json:"MeterValueStart,omitempty"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID *OperatorIDType `json:"OperatorID,omitempty"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// SessionStart The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionStart *time.Time `json:"SessionStart,omitempty"`

	// Type The type of ChargingNotification
	Type *ChargingNotificationType `json:"Type,omitempty"`
}

// ERoamingPushEVSEPricing eRoamingPushEVSEPricing is a message that is sent in order to upload a list of EVSEs and the pricing products (i.e. tarrifs) applicable for (charging or reservation) sessions at these EVSEs.
type ERoamingPushEVSEPricing struct {
	// ActionType Describes the action that has to be performed by Hubject with the provided data.
	ActionType ERoamingPushEVSEPricingActionType `json:"ActionType"`

	// EVSEPricing A list of EVSEs and their respective pricing product relation
	EVSEPricing []struct {
		// EvseID The ID that identifies the charging spot.
		//
		// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
		//
		// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
		// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
		//
		// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
		//
		// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
		//
		// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
		//
		// Example DIN: “+49*810*000*438”
		EvseID EvseID `json:"EvseID"`

		// EvseIDProductList A list of pricing products applicable per EvseID
		EvseIDProductList []ProductID `json:"EvseIDProductList"`

		// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
		//
		// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
		//
		// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
		//
		// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
		//
		// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
		//
		// Examples ISO: “DE8EO”, “DE-8EO”
		//
		// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
		//
		//  In case the data is to be made available for all EMPs (e.g. for Offer-to-All prices), the asterix character (*) can be set as the value in this field.
		//
		ProviderID ProviderIDAsterisk `json:"ProviderID"`
	} `json:"EVSEPricing"`
}

// ERoamingPushEVSEPricingActionType Describes the action that has to be performed by Hubject with the provided data.
type ERoamingPushEVSEPricingActionType string

// ERoamingPushEvseData defines model for eRoamingPushEvseData.
type ERoamingPushEvseData struct {
	// ActionType Describes the action that has to be performed by Hubject with the provided data.
	ActionType       ERoamingPushEvseDataActionType `json:"ActionType"`
	OperatorEvseData OperatorEvseDataType           `json:"OperatorEvseData"`
}

// ERoamingPushEvseDataActionType Describes the action that has to be performed by Hubject with the provided data.
type ERoamingPushEvseDataActionType string

// ERoamingPushEvseStatus eRoamingPushEvseStatus is a message that is sent in order to upload EVSE status data to Hubject.
type ERoamingPushEvseStatus struct {
	// ActionType Describes the action that has to be performed by Hubject with the provided data.
	ActionType ERoamingPushEvseStatusActionType `json:"ActionType"`

	// OperatorEvseStatus Indicates the Eves status
	OperatorEvseStatus OperatorEvseStatus `json:"OperatorEvseStatus"`
}

// ERoamingPushEvseStatusActionType Describes the action that has to be performed by Hubject with the provided data.
type ERoamingPushEvseStatusActionType string

// ERoamingPushPricingProductData eRoamingPushPricingProductData is a message that is sent in order to upload data pertaining to a CPO’s pricing products (i.e. tarrifs) to the Hubject system.
type ERoamingPushPricingProductData struct {
	// ActionType Describes the action that has to be performed by Hubject with the provided data.
	ActionType ERoamingPushPricingProductDataActionType `json:"ActionType"`

	// PricingProductData Details of pricing products offered by a particular operator for a specific provider
	PricingProductData struct {
		// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
		//
		// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
		// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
		//
		// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
		//
		// Examples ISO: “DE*A36”, “DEA36”
		//
		// Example DIN: “+49*536”
		OperatorID OperatorIDType `json:"OperatorID"`

		// OperatorName Free text for operator
		OperatorName *string `json:"OperatorName,omitempty"`

		// PricingDefaultPrice A default price for pricing sessions at undefined EVSEs
		PricingDefaultPrice float32 `json:"PricingDefaultPrice"`

		// PricingDefaultPriceCurrency The ProductPriceCurrencyType allows for the list of active codes of the official ISO 4217 currency names.
		//
		// For the full list of active codes of the official ISO 4217 currencies, see: [https://www.iso.org/iso-4217-currency-codes.html](https://www.iso.org/iso-4217-currency-codes.html)
		//
		// Examples:
		//
		// | Option | Description |
		// | ------ | ----------- |
		// | EUR | Euro |
		// | CHF | Swiss franc |
		// | CAD | Canadian Dollar |
		// | GBP | Pound sterling
		PricingDefaultPriceCurrency CurrencyID `json:"PricingDefaultPriceCurrency"`

		// PricingDefaultReferenceUnit Default Reference Unit in time or kWh
		//
		// | Option | Description |
		// | ------ | ----------- |
		// | HOUR | Defined Reference Unit Type |
		// | KILOWATT_HOUR | Defined Reference Unit Type |
		// | MINUTE | Defined Reference Unit Type |
		PricingDefaultReferenceUnit ReferenceUnit `json:"PricingDefaultReferenceUnit"`

		// PricingProductDataRecords A list of pricing products
		PricingProductDataRecords []PricingProductDataRecord `json:"PricingProductDataRecords"`

		// ProviderID The ProviderID is defined by Hubject and is used to identify the EMP
		//
		// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN
		//
		// `^([A-Za-z]{2}\-?[A-Za-z0-9]{3}|[A-Za-z]{2}[\*|-]?[A-Za-z0-9]{3})$`
		//
		// The expression validates the string as ProviderID including the preceding country code, which is part of EvcoID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
		//
		// In case the ProviderID is provided corresponding to ISO, the country code `MUST` be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “-” is optional.
		//
		// Examples ISO: “DE8EO”, “DE-8EO”
		//
		// Examples DIN: “DE8EO”, “DE*8EO”, “DE-8EO”
		//
		//  In case the data is to be made available for all EMPs (e.g. for Offer-to-All prices), the asterix character (*) can be set as the value in this field.
		//
		ProviderID ProviderIDAsterisk `json:"ProviderID"`
	} `json:"PricingProductData"`
}

// ERoamingPushPricingProductDataActionType Describes the action that has to be performed by Hubject with the provided data.
type ERoamingPushPricingProductDataActionType string

// ExternalID defines model for externalID.
type ExternalID = string

// OperatorID defines model for operatorID.
type OperatorID = string

// ProviderID defines model for providerID.
type ProviderID = string

// ERoamingAcknowledgment The acknowledgement is a message that is sent in response to several requests.
//
// * To `SEND` and `RECEIVE`
// * Implementation: `MANDATORY`
type ERoamingAcknowledgment = ERoamingAcknowledgmen

// ERoamingChargingNotificationsV11JSONBody defines parameters for ERoamingChargingNotificationsV11.
type ERoamingChargingNotificationsV11JSONBody struct {
	// CPOPartnerSessionID Optional field containing the session ID assigned by the CPO to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	CPOPartnerSessionID *string `json:"CPOPartnerSessionID,omitempty"`

	// ChargingDuration Charging Duration = EventOccurred - Charging Duration. It is a time in millisecond.
	//
	// Either ChargingDuration or ConsumedEnergyProgress should be provided. Both can also be provided with each progress notification.
	ChargingDuration *int `json:"ChargingDuration,omitempty"`

	// ChargingEnd The date and time at which the charging process stoped.
	ChargingEnd *time.Time `json:"ChargingEnd,omitempty"`

	// ChargingStart The date and time at which the charging process started.
	ChargingStart *time.Time `json:"ChargingStart,omitempty"`

	// ConsumedEnergy The difference between MeterValueEnd and MeterValueStart in kWh.
	ConsumedEnergy *float32 `json:"ConsumedEnergy,omitempty"`

	// ConsumedEnergyProgress This is consumed energy when from Start of charging process till the charging progress notification generated (EventOccurred)
	//
	// Either ChargingDuration or ConsumedEnergyProgress should be provided. Both can also be provided with each progress notification.
	ConsumedEnergyProgress *float32 `json:"ConsumedEnergyProgress,omitempty"`

	// EMPPartnerSessionID Optional field containing the session ID assigned by an EMP to the related operation.
	//
	// Partner systems can use this field to link their own session handling to HBS processes.
	EMPPartnerSessionID *string `json:"EMPPartnerSessionID,omitempty"`

	// ErrorAdditionalInfo The CPO can put in the additional information about the error
	ErrorAdditionalInfo *string `json:"ErrorAdditionalInfo,omitempty"`

	// ErrorType | Option | Description |
	// | ------ | ----------- |
	// | ConnectorError | Charging process cannot be started or stopped. EV driver needs to check if the the Plug is properly inserted or taken out from socket. |
	// | CriticalError | Charging process stopped abruptly. Reason: Physical check at the station is required. Station cannot be reset online. <br /> Or <br /> Error with the software or hardware of the station locally. <br /> Or <br /> Communication failure with the vehicle. <br /> Or <br /> The error needs to be investigated <br /> Or <br /> Ground Failure |
	ErrorType *ERoamingChargingNotificationsV11JSONBodyErrorType `json:"ErrorType,omitempty"`

	// EventOccurred The date and time at which the charging progress parameters are captured.
	EventOccurred *time.Time `json:"EventOccurred,omitempty"`

	// EvseID The ID that identifies the charging spot.
	//
	// A string that `MUST` be valid with respect to the following regular expression: ISO | DIN.
	//
	// `^(([A-Za-z]{2}\*?[A-Za-z0-9]{3}\*?E[A-Za-z0-9\*]{1,30})|(\+?[0-9]{1,3}\*[0-9]{3}\*[0-9\*]{1,32}))$`
	// The expression validates the string as EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118-1.
	//
	// In case the EvseID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional. Furthermore the ID MUST provide an “E” after the OperatorID in order to identify the ID as ISO EvseID without doubt.
	//
	// In case the EvseID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*AB7*E840*6487”, “DEAB7E8406487”
	//
	// Example DIN: “+49*810*000*438”
	EvseID *EvseID `json:"EvseID,omitempty"`

	// Identification Authentication data
	//
	// 1. The option RFIDIdentification `MUST` not be used in the eRoamingAuthorization process. For RFID Authorization, only the option RFIDMifareFamilyIdentification `SHOULD` be used in the respective eRoamingAuthorization messages.
	// 2. For the Remote Authorization process, only the option RemoteIdentification MUST be used in the respective messages.
	Identification *Identification `json:"Identification,omitempty"`

	// MeterValueEnd The ending meter value in kWh.
	MeterValueEnd *float32 `json:"MeterValueEnd,omitempty"`

	// MeterValueInBetween List of meter values that may have been taken in between (kWh).
	MeterValueInBetween *struct {
		MeterValues *[]float32 `json:"meterValues,omitempty"`
	} `json:"MeterValueInBetween,omitempty"`

	// MeterValueStart The starting meter value in kWh.
	MeterValueStart *float32 `json:"MeterValueStart,omitempty"`

	// OperatorID A string that MUST be valid with respect to the following regular expression: ISO | DIN
	//
	// ^(([A-Za-z]{2}\*?[A-Za-z0-9]{3})|(\+?[0-9]{1,3}\*[0-9]{3}))$
	// The expression validates the string as OperatorID including the preceding country code, which is part of EvseID. It supports both definitions DIN SPEC 91286:2011-11 as well as ISO 15118. In case the OperatorID is provided corresponding to ISO, the country code MUST be provided as Alpha-2-Code (DIN EN ISO-3166-1) and the separator character “*” is optional.
	//
	// In case the OperatorID is provided corresponding to DIN, the country code MUST be provided according to the international telecommunication numbering plan (ITU-T E.164:11/2010) and the separator character “*” is mandatory.
	//
	// Examples ISO: “DE*A36”, “DEA36”
	//
	// Example DIN: “+49*536”
	OperatorID *OperatorIDType `json:"OperatorID,omitempty"`

	// PartnerProductID The ProductIDType defines some standard values (see below). The type however also supports custom ProductIDs that can be specified by partners (as a string of 50 characters maximum length).
	// | Option | Description |
	// |--------|-------------|
	// | Standard Price | Standard Price |
	// | AC1 | Product for AC 1 Phase charging |
	// | AC3 | Product for AC 3 Phase charging |
	// | DC | Product for DC charging |
	// | CustomProductID | There is no option “CustomProductID”, this sample option is meant to indicates that custom product ID specifications by partners (as a string of 50 characters maximum length) are allowed as well.|
	PartnerProductID *ProductID `json:"PartnerProductID,omitempty"`

	// PenaltyTimeStart The date and time at which the penalty time start after the grace period.
	PenaltyTimeStart *time.Time `json:"PenaltyTimeStart,omitempty"`

	// SessionEnd The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionEnd *time.Time `json:"SessionEnd,omitempty"`

	// SessionID The Hubject SessionID that identifies the process
	//
	// A string that `MUST` be valid with respect to the following regular expression:
	//
	// `^[A-Za-z0-9]{8}(-[A-Za-z0-9]{4}){3}-[A-Za-z0-9]{12}$`
	//
	// The expression validates the string as a GUID.
	//
	// Example: “b2688855-7f00-0002-6d8e-48d883f6abb6”
	SessionID *SessionID `json:"SessionID,omitempty"`

	// SessionStart The date and time at which the session started, e.g. swipe of RFID or cable connected.
	SessionStart *time.Time `json:"SessionStart,omitempty"`

	// Type The type of ChargingNotification
	Type *ChargingNotificationType `json:"Type,omitempty"`
}

// ERoamingChargingNotificationsV11JSONBodyErrorType defines parameters for ERoamingChargingNotificationsV11.
type ERoamingChargingNotificationsV11JSONBodyErrorType string

// ERoamingChargeDetailRecordV22JSONRequestBody defines body for ERoamingChargeDetailRecordV22 for application/json ContentType.
type ERoamingChargeDetailRecordV22JSONRequestBody = ERoamingChargeDetailRecord

// ERoamingAuthorizeStartV21JSONRequestBody defines body for ERoamingAuthorizeStartV21 for application/json ContentType.
type ERoamingAuthorizeStartV21JSONRequestBody = ERoamingAuthorizeStart

// ERoamingAuthorizeStopV21JSONRequestBody defines body for ERoamingAuthorizeStopV21 for application/json ContentType.
type ERoamingAuthorizeStopV21JSONRequestBody = ERoamingAuthorizeStop

// ERoamingAuthorizeRemoteStopV21JSONRequestBody defines body for ERoamingAuthorizeRemoteStopV21 for application/json ContentType.
type ERoamingAuthorizeRemoteStopV21JSONRequestBody = ERoamingAuthorizeRemoteStop

// ERoamingAuthorizeRemoteStartV21JSONRequestBody defines body for ERoamingAuthorizeRemoteStartV21 for application/json ContentType.
type ERoamingAuthorizeRemoteStartV21JSONRequestBody = ERoamingAuthorizeRemoteStart

// ERoamingPushEVSEPricingV10JSONRequestBody defines body for ERoamingPushEVSEPricingV10 for application/json ContentType.
type ERoamingPushEVSEPricingV10JSONRequestBody = ERoamingPushEVSEPricing

// ERoamingPushPricingProductDataV10JSONRequestBody defines body for ERoamingPushPricingProductDataV10 for application/json ContentType.
type ERoamingPushPricingProductDataV10JSONRequestBody = ERoamingPushPricingProductData

// ERoamingPushEvseStatusV21JSONRequestBody defines body for ERoamingPushEvseStatusV21 for application/json ContentType.
type ERoamingPushEvseStatusV21JSONRequestBody = ERoamingPushEvseStatus

// ERoamingPushEvseDataV23JSONRequestBody defines body for ERoamingPushEvseDataV23 for application/json ContentType.
type ERoamingPushEvseDataV23JSONRequestBody = ERoamingPushEvseData

// ERoamingChargingNotificationsV11JSONRequestBody defines body for ERoamingChargingNotificationsV11 for application/json ContentType.
type ERoamingChargingNotificationsV11JSONRequestBody ERoamingChargingNotificationsV11JSONBody

// ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody defines body for ERoamingAuthorizeRemoteReservationStartV11 for application/json ContentType.
type ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody = ERoamingAuthorizeRemoteReservationStart

// ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody defines body for ERoamingAuthorizeRemoteReservationStopV1 for application/json ContentType.
type ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody = ERoamingAuthorizeRemoteReservationStop

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ERoamingChargeDetailRecordV22WithBody request with any body
	ERoamingChargeDetailRecordV22WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingChargeDetailRecordV22(ctx context.Context, operatorID OperatorID, body ERoamingChargeDetailRecordV22JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeStartV21WithBody request with any body
	ERoamingAuthorizeStartV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeStartV21(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeStopV21WithBody request with any body
	ERoamingAuthorizeStopV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeStopV21(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeRemoteStopV21WithBody request with any body
	ERoamingAuthorizeRemoteStopV21WithBody(ctx context.Context, externalID ExternalID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeRemoteStopV21(ctx context.Context, externalID ExternalID, body ERoamingAuthorizeRemoteStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeRemoteStartV21WithBody request with any body
	ERoamingAuthorizeRemoteStartV21WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeRemoteStartV21(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingPushEVSEPricingV10WithBody request with any body
	ERoamingPushEVSEPricingV10WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingPushEVSEPricingV10(ctx context.Context, operatorID OperatorID, body ERoamingPushEVSEPricingV10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingPushPricingProductDataV10WithBody request with any body
	ERoamingPushPricingProductDataV10WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingPushPricingProductDataV10(ctx context.Context, operatorID OperatorID, body ERoamingPushPricingProductDataV10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingPushEvseStatusV21WithBody request with any body
	ERoamingPushEvseStatusV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingPushEvseStatusV21(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseStatusV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingPushEvseDataV23WithBody request with any body
	ERoamingPushEvseDataV23WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingPushEvseDataV23(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseDataV23JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingChargingNotificationsV11WithBody request with any body
	ERoamingChargingNotificationsV11WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingChargingNotificationsV11(ctx context.Context, body ERoamingChargingNotificationsV11JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeRemoteReservationStartV11WithBody request with any body
	ERoamingAuthorizeRemoteReservationStartV11WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeRemoteReservationStartV11(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ERoamingAuthorizeRemoteReservationStopV1WithBody request with any body
	ERoamingAuthorizeRemoteReservationStopV1WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ERoamingAuthorizeRemoteReservationStopV1(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ERoamingChargeDetailRecordV22WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingChargeDetailRecordV22RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingChargeDetailRecordV22(ctx context.Context, operatorID OperatorID, body ERoamingChargeDetailRecordV22JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingChargeDetailRecordV22Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeStartV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeStartV21RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeStartV21(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeStartV21Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeStopV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeStopV21RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeStopV21(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeStopV21Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteStopV21WithBody(ctx context.Context, externalID ExternalID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteStopV21RequestWithBody(c.Server, externalID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteStopV21(ctx context.Context, externalID ExternalID, body ERoamingAuthorizeRemoteStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteStopV21Request(c.Server, externalID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteStartV21WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteStartV21RequestWithBody(c.Server, providerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteStartV21(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteStartV21Request(c.Server, providerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEVSEPricingV10WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEVSEPricingV10RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEVSEPricingV10(ctx context.Context, operatorID OperatorID, body ERoamingPushEVSEPricingV10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEVSEPricingV10Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushPricingProductDataV10WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushPricingProductDataV10RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushPricingProductDataV10(ctx context.Context, operatorID OperatorID, body ERoamingPushPricingProductDataV10JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushPricingProductDataV10Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEvseStatusV21WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEvseStatusV21RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEvseStatusV21(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseStatusV21JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEvseStatusV21Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEvseDataV23WithBody(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEvseDataV23RequestWithBody(c.Server, operatorID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingPushEvseDataV23(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseDataV23JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingPushEvseDataV23Request(c.Server, operatorID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingChargingNotificationsV11WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingChargingNotificationsV11RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingChargingNotificationsV11(ctx context.Context, body ERoamingChargingNotificationsV11JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingChargingNotificationsV11Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteReservationStartV11WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteReservationStartV11RequestWithBody(c.Server, providerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteReservationStartV11(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteReservationStartV11Request(c.Server, providerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteReservationStopV1WithBody(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteReservationStopV1RequestWithBody(c.Server, providerID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ERoamingAuthorizeRemoteReservationStopV1(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewERoamingAuthorizeRemoteReservationStopV1Request(c.Server, providerID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewERoamingChargeDetailRecordV22Request calls the generic ERoamingChargeDetailRecordV22 builder with application/json body
func NewERoamingChargeDetailRecordV22Request(server string, operatorID OperatorID, body ERoamingChargeDetailRecordV22JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingChargeDetailRecordV22RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingChargeDetailRecordV22RequestWithBody generates requests for ERoamingChargeDetailRecordV22 with any type of body
func NewERoamingChargeDetailRecordV22RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdrmgmt/v22/operators/%s/charge-detail-record", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeStartV21Request calls the generic ERoamingAuthorizeStartV21 builder with application/json body
func NewERoamingAuthorizeStartV21Request(server string, operatorID OperatorID, body ERoamingAuthorizeStartV21JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeStartV21RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingAuthorizeStartV21RequestWithBody generates requests for ERoamingAuthorizeStartV21 with any type of body
func NewERoamingAuthorizeStartV21RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charging/v21/operators/%s/authorize/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeStopV21Request calls the generic ERoamingAuthorizeStopV21 builder with application/json body
func NewERoamingAuthorizeStopV21Request(server string, operatorID OperatorID, body ERoamingAuthorizeStopV21JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeStopV21RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingAuthorizeStopV21RequestWithBody generates requests for ERoamingAuthorizeStopV21 with any type of body
func NewERoamingAuthorizeStopV21RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charging/v21/operators/%s/authorize/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeRemoteStopV21Request calls the generic ERoamingAuthorizeRemoteStopV21 builder with application/json body
func NewERoamingAuthorizeRemoteStopV21Request(server string, externalID ExternalID, body ERoamingAuthorizeRemoteStopV21JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeRemoteStopV21RequestWithBody(server, externalID, "application/json", bodyReader)
}

// NewERoamingAuthorizeRemoteStopV21RequestWithBody generates requests for ERoamingAuthorizeRemoteStopV21 with any type of body
func NewERoamingAuthorizeRemoteStopV21RequestWithBody(server string, externalID ExternalID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalID", runtime.ParamLocationPath, externalID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charging/v21/providers/%s/authorize-remote/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeRemoteStartV21Request calls the generic ERoamingAuthorizeRemoteStartV21 builder with application/json body
func NewERoamingAuthorizeRemoteStartV21Request(server string, providerID ProviderID, body ERoamingAuthorizeRemoteStartV21JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeRemoteStartV21RequestWithBody(server, providerID, "application/json", bodyReader)
}

// NewERoamingAuthorizeRemoteStartV21RequestWithBody generates requests for ERoamingAuthorizeRemoteStartV21 with any type of body
func NewERoamingAuthorizeRemoteStartV21RequestWithBody(server string, providerID ProviderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "providerID", runtime.ParamLocationPath, providerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charging/v21/providers/%s/authorize-remote/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingPushEVSEPricingV10Request calls the generic ERoamingPushEVSEPricingV10 builder with application/json body
func NewERoamingPushEVSEPricingV10Request(server string, operatorID OperatorID, body ERoamingPushEVSEPricingV10JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingPushEVSEPricingV10RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingPushEVSEPricingV10RequestWithBody generates requests for ERoamingPushEVSEPricingV10 with any type of body
func NewERoamingPushEVSEPricingV10RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dynamicpricing/v10/operators/%s/evse-pricing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingPushPricingProductDataV10Request calls the generic ERoamingPushPricingProductDataV10 builder with application/json body
func NewERoamingPushPricingProductDataV10Request(server string, operatorID OperatorID, body ERoamingPushPricingProductDataV10JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingPushPricingProductDataV10RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingPushPricingProductDataV10RequestWithBody generates requests for ERoamingPushPricingProductDataV10 with any type of body
func NewERoamingPushPricingProductDataV10RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dynamicpricing/v10/operators/%s/pricing-products", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingPushEvseStatusV21Request calls the generic ERoamingPushEvseStatusV21 builder with application/json body
func NewERoamingPushEvseStatusV21Request(server string, operatorID OperatorID, body ERoamingPushEvseStatusV21JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingPushEvseStatusV21RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingPushEvseStatusV21RequestWithBody generates requests for ERoamingPushEvseStatusV21 with any type of body
func NewERoamingPushEvseStatusV21RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/evsepush/v21/operators/%s/status-records", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingPushEvseDataV23Request calls the generic ERoamingPushEvseDataV23 builder with application/json body
func NewERoamingPushEvseDataV23Request(server string, operatorID OperatorID, body ERoamingPushEvseDataV23JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingPushEvseDataV23RequestWithBody(server, operatorID, "application/json", bodyReader)
}

// NewERoamingPushEvseDataV23RequestWithBody generates requests for ERoamingPushEvseDataV23 with any type of body
func NewERoamingPushEvseDataV23RequestWithBody(server string, operatorID OperatorID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "operatorID", runtime.ParamLocationPath, operatorID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/evsepush/v23/operators/%s/data-records", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingChargingNotificationsV11Request calls the generic ERoamingChargingNotificationsV11 builder with application/json body
func NewERoamingChargingNotificationsV11Request(server string, body ERoamingChargingNotificationsV11JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingChargingNotificationsV11RequestWithBody(server, "application/json", bodyReader)
}

// NewERoamingChargingNotificationsV11RequestWithBody generates requests for ERoamingChargingNotificationsV11 with any type of body
func NewERoamingChargingNotificationsV11RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notificationmgmt/v11/charging-notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeRemoteReservationStartV11Request calls the generic ERoamingAuthorizeRemoteReservationStartV11 builder with application/json body
func NewERoamingAuthorizeRemoteReservationStartV11Request(server string, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeRemoteReservationStartV11RequestWithBody(server, providerID, "application/json", bodyReader)
}

// NewERoamingAuthorizeRemoteReservationStartV11RequestWithBody generates requests for ERoamingAuthorizeRemoteReservationStartV11 with any type of body
func NewERoamingAuthorizeRemoteReservationStartV11RequestWithBody(server string, providerID ProviderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "providerID", runtime.ParamLocationPath, providerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reservation/v11/providers/%s/reservation-start-request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewERoamingAuthorizeRemoteReservationStopV1Request calls the generic ERoamingAuthorizeRemoteReservationStopV1 builder with application/json body
func NewERoamingAuthorizeRemoteReservationStopV1Request(server string, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewERoamingAuthorizeRemoteReservationStopV1RequestWithBody(server, providerID, "application/json", bodyReader)
}

// NewERoamingAuthorizeRemoteReservationStopV1RequestWithBody generates requests for ERoamingAuthorizeRemoteReservationStopV1 with any type of body
func NewERoamingAuthorizeRemoteReservationStopV1RequestWithBody(server string, providerID ProviderID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "providerID", runtime.ParamLocationPath, providerID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reservation/v11/providers/%s/reservation-stop-request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ERoamingChargeDetailRecordV22WithBodyWithResponse request with any body
	ERoamingChargeDetailRecordV22WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingChargeDetailRecordV22Response, error)

	ERoamingChargeDetailRecordV22WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingChargeDetailRecordV22JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingChargeDetailRecordV22Response, error)

	// ERoamingAuthorizeStartV21WithBodyWithResponse request with any body
	ERoamingAuthorizeStartV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStartV21Response, error)

	ERoamingAuthorizeStartV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStartV21Response, error)

	// ERoamingAuthorizeStopV21WithBodyWithResponse request with any body
	ERoamingAuthorizeStopV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStopV21Response, error)

	ERoamingAuthorizeStopV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStopV21Response, error)

	// ERoamingAuthorizeRemoteStopV21WithBodyWithResponse request with any body
	ERoamingAuthorizeRemoteStopV21WithBodyWithResponse(ctx context.Context, externalID ExternalID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStopV21Response, error)

	ERoamingAuthorizeRemoteStopV21WithResponse(ctx context.Context, externalID ExternalID, body ERoamingAuthorizeRemoteStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStopV21Response, error)

	// ERoamingAuthorizeRemoteStartV21WithBodyWithResponse request with any body
	ERoamingAuthorizeRemoteStartV21WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStartV21Response, error)

	ERoamingAuthorizeRemoteStartV21WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStartV21Response, error)

	// ERoamingPushEVSEPricingV10WithBodyWithResponse request with any body
	ERoamingPushEVSEPricingV10WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEVSEPricingV10Response, error)

	ERoamingPushEVSEPricingV10WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEVSEPricingV10JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEVSEPricingV10Response, error)

	// ERoamingPushPricingProductDataV10WithBodyWithResponse request with any body
	ERoamingPushPricingProductDataV10WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushPricingProductDataV10Response, error)

	ERoamingPushPricingProductDataV10WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushPricingProductDataV10JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushPricingProductDataV10Response, error)

	// ERoamingPushEvseStatusV21WithBodyWithResponse request with any body
	ERoamingPushEvseStatusV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEvseStatusV21Response, error)

	ERoamingPushEvseStatusV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseStatusV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEvseStatusV21Response, error)

	// ERoamingPushEvseDataV23WithBodyWithResponse request with any body
	ERoamingPushEvseDataV23WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEvseDataV23Response, error)

	ERoamingPushEvseDataV23WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseDataV23JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEvseDataV23Response, error)

	// ERoamingChargingNotificationsV11WithBodyWithResponse request with any body
	ERoamingChargingNotificationsV11WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingChargingNotificationsV11Response, error)

	ERoamingChargingNotificationsV11WithResponse(ctx context.Context, body ERoamingChargingNotificationsV11JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingChargingNotificationsV11Response, error)

	// ERoamingAuthorizeRemoteReservationStartV11WithBodyWithResponse request with any body
	ERoamingAuthorizeRemoteReservationStartV11WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStartV11Response, error)

	ERoamingAuthorizeRemoteReservationStartV11WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStartV11Response, error)

	// ERoamingAuthorizeRemoteReservationStopV1WithBodyWithResponse request with any body
	ERoamingAuthorizeRemoteReservationStopV1WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStopV1Response, error)

	ERoamingAuthorizeRemoteReservationStopV1WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStopV1Response, error)
}

type ERoamingChargeDetailRecordV22Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingChargeDetailRecordV22Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingChargeDetailRecordV22Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeStartV21Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAuthorizationStart
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeStartV21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeStartV21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeStopV21Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAuthorizationStop
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeStopV21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeStopV21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeRemoteStopV21Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeRemoteStopV21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeRemoteStopV21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeRemoteStartV21Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeRemoteStartV21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeRemoteStartV21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingPushEVSEPricingV10Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingPushEVSEPricingV10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingPushEVSEPricingV10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingPushPricingProductDataV10Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingPushPricingProductDataV10Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingPushPricingProductDataV10Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingPushEvseStatusV21Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingPushEvseStatusV21Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingPushEvseStatusV21Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingPushEvseDataV23Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingPushEvseDataV23Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingPushEvseDataV23Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingChargingNotificationsV11Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingChargingNotificationsV11Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingChargingNotificationsV11Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeRemoteReservationStartV11Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeRemoteReservationStartV11Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeRemoteReservationStartV11Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ERoamingAuthorizeRemoteReservationStopV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ERoamingAcknowledgmen
}

// Status returns HTTPResponse.Status
func (r ERoamingAuthorizeRemoteReservationStopV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ERoamingAuthorizeRemoteReservationStopV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ERoamingChargeDetailRecordV22WithBodyWithResponse request with arbitrary body returning *ERoamingChargeDetailRecordV22Response
func (c *ClientWithResponses) ERoamingChargeDetailRecordV22WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingChargeDetailRecordV22Response, error) {
	rsp, err := c.ERoamingChargeDetailRecordV22WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingChargeDetailRecordV22Response(rsp)
}

func (c *ClientWithResponses) ERoamingChargeDetailRecordV22WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingChargeDetailRecordV22JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingChargeDetailRecordV22Response, error) {
	rsp, err := c.ERoamingChargeDetailRecordV22(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingChargeDetailRecordV22Response(rsp)
}

// ERoamingAuthorizeStartV21WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeStartV21Response
func (c *ClientWithResponses) ERoamingAuthorizeStartV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStartV21Response, error) {
	rsp, err := c.ERoamingAuthorizeStartV21WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeStartV21Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeStartV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStartV21Response, error) {
	rsp, err := c.ERoamingAuthorizeStartV21(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeStartV21Response(rsp)
}

// ERoamingAuthorizeStopV21WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeStopV21Response
func (c *ClientWithResponses) ERoamingAuthorizeStopV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStopV21Response, error) {
	rsp, err := c.ERoamingAuthorizeStopV21WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeStopV21Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeStopV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingAuthorizeStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeStopV21Response, error) {
	rsp, err := c.ERoamingAuthorizeStopV21(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeStopV21Response(rsp)
}

// ERoamingAuthorizeRemoteStopV21WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeRemoteStopV21Response
func (c *ClientWithResponses) ERoamingAuthorizeRemoteStopV21WithBodyWithResponse(ctx context.Context, externalID ExternalID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStopV21Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteStopV21WithBody(ctx, externalID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteStopV21Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeRemoteStopV21WithResponse(ctx context.Context, externalID ExternalID, body ERoamingAuthorizeRemoteStopV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStopV21Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteStopV21(ctx, externalID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteStopV21Response(rsp)
}

// ERoamingAuthorizeRemoteStartV21WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeRemoteStartV21Response
func (c *ClientWithResponses) ERoamingAuthorizeRemoteStartV21WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStartV21Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteStartV21WithBody(ctx, providerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteStartV21Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeRemoteStartV21WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteStartV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteStartV21Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteStartV21(ctx, providerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteStartV21Response(rsp)
}

// ERoamingPushEVSEPricingV10WithBodyWithResponse request with arbitrary body returning *ERoamingPushEVSEPricingV10Response
func (c *ClientWithResponses) ERoamingPushEVSEPricingV10WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEVSEPricingV10Response, error) {
	rsp, err := c.ERoamingPushEVSEPricingV10WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEVSEPricingV10Response(rsp)
}

func (c *ClientWithResponses) ERoamingPushEVSEPricingV10WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEVSEPricingV10JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEVSEPricingV10Response, error) {
	rsp, err := c.ERoamingPushEVSEPricingV10(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEVSEPricingV10Response(rsp)
}

// ERoamingPushPricingProductDataV10WithBodyWithResponse request with arbitrary body returning *ERoamingPushPricingProductDataV10Response
func (c *ClientWithResponses) ERoamingPushPricingProductDataV10WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushPricingProductDataV10Response, error) {
	rsp, err := c.ERoamingPushPricingProductDataV10WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushPricingProductDataV10Response(rsp)
}

func (c *ClientWithResponses) ERoamingPushPricingProductDataV10WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushPricingProductDataV10JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushPricingProductDataV10Response, error) {
	rsp, err := c.ERoamingPushPricingProductDataV10(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushPricingProductDataV10Response(rsp)
}

// ERoamingPushEvseStatusV21WithBodyWithResponse request with arbitrary body returning *ERoamingPushEvseStatusV21Response
func (c *ClientWithResponses) ERoamingPushEvseStatusV21WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEvseStatusV21Response, error) {
	rsp, err := c.ERoamingPushEvseStatusV21WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEvseStatusV21Response(rsp)
}

func (c *ClientWithResponses) ERoamingPushEvseStatusV21WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseStatusV21JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEvseStatusV21Response, error) {
	rsp, err := c.ERoamingPushEvseStatusV21(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEvseStatusV21Response(rsp)
}

// ERoamingPushEvseDataV23WithBodyWithResponse request with arbitrary body returning *ERoamingPushEvseDataV23Response
func (c *ClientWithResponses) ERoamingPushEvseDataV23WithBodyWithResponse(ctx context.Context, operatorID OperatorID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingPushEvseDataV23Response, error) {
	rsp, err := c.ERoamingPushEvseDataV23WithBody(ctx, operatorID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEvseDataV23Response(rsp)
}

func (c *ClientWithResponses) ERoamingPushEvseDataV23WithResponse(ctx context.Context, operatorID OperatorID, body ERoamingPushEvseDataV23JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingPushEvseDataV23Response, error) {
	rsp, err := c.ERoamingPushEvseDataV23(ctx, operatorID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingPushEvseDataV23Response(rsp)
}

// ERoamingChargingNotificationsV11WithBodyWithResponse request with arbitrary body returning *ERoamingChargingNotificationsV11Response
func (c *ClientWithResponses) ERoamingChargingNotificationsV11WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingChargingNotificationsV11Response, error) {
	rsp, err := c.ERoamingChargingNotificationsV11WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingChargingNotificationsV11Response(rsp)
}

func (c *ClientWithResponses) ERoamingChargingNotificationsV11WithResponse(ctx context.Context, body ERoamingChargingNotificationsV11JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingChargingNotificationsV11Response, error) {
	rsp, err := c.ERoamingChargingNotificationsV11(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingChargingNotificationsV11Response(rsp)
}

// ERoamingAuthorizeRemoteReservationStartV11WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeRemoteReservationStartV11Response
func (c *ClientWithResponses) ERoamingAuthorizeRemoteReservationStartV11WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStartV11Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteReservationStartV11WithBody(ctx, providerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteReservationStartV11Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeRemoteReservationStartV11WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStartV11JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStartV11Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteReservationStartV11(ctx, providerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteReservationStartV11Response(rsp)
}

// ERoamingAuthorizeRemoteReservationStopV1WithBodyWithResponse request with arbitrary body returning *ERoamingAuthorizeRemoteReservationStopV1Response
func (c *ClientWithResponses) ERoamingAuthorizeRemoteReservationStopV1WithBodyWithResponse(ctx context.Context, providerID ProviderID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStopV1Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteReservationStopV1WithBody(ctx, providerID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteReservationStopV1Response(rsp)
}

func (c *ClientWithResponses) ERoamingAuthorizeRemoteReservationStopV1WithResponse(ctx context.Context, providerID ProviderID, body ERoamingAuthorizeRemoteReservationStopV1JSONRequestBody, reqEditors ...RequestEditorFn) (*ERoamingAuthorizeRemoteReservationStopV1Response, error) {
	rsp, err := c.ERoamingAuthorizeRemoteReservationStopV1(ctx, providerID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseERoamingAuthorizeRemoteReservationStopV1Response(rsp)
}

// ParseERoamingChargeDetailRecordV22Response parses an HTTP response from a ERoamingChargeDetailRecordV22WithResponse call
func ParseERoamingChargeDetailRecordV22Response(rsp *http.Response) (*ERoamingChargeDetailRecordV22Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingChargeDetailRecordV22Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeStartV21Response parses an HTTP response from a ERoamingAuthorizeStartV21WithResponse call
func ParseERoamingAuthorizeStartV21Response(rsp *http.Response) (*ERoamingAuthorizeStartV21Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeStartV21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAuthorizationStart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeStopV21Response parses an HTTP response from a ERoamingAuthorizeStopV21WithResponse call
func ParseERoamingAuthorizeStopV21Response(rsp *http.Response) (*ERoamingAuthorizeStopV21Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeStopV21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAuthorizationStop
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeRemoteStopV21Response parses an HTTP response from a ERoamingAuthorizeRemoteStopV21WithResponse call
func ParseERoamingAuthorizeRemoteStopV21Response(rsp *http.Response) (*ERoamingAuthorizeRemoteStopV21Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeRemoteStopV21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeRemoteStartV21Response parses an HTTP response from a ERoamingAuthorizeRemoteStartV21WithResponse call
func ParseERoamingAuthorizeRemoteStartV21Response(rsp *http.Response) (*ERoamingAuthorizeRemoteStartV21Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeRemoteStartV21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingPushEVSEPricingV10Response parses an HTTP response from a ERoamingPushEVSEPricingV10WithResponse call
func ParseERoamingPushEVSEPricingV10Response(rsp *http.Response) (*ERoamingPushEVSEPricingV10Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingPushEVSEPricingV10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingPushPricingProductDataV10Response parses an HTTP response from a ERoamingPushPricingProductDataV10WithResponse call
func ParseERoamingPushPricingProductDataV10Response(rsp *http.Response) (*ERoamingPushPricingProductDataV10Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingPushPricingProductDataV10Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingPushEvseStatusV21Response parses an HTTP response from a ERoamingPushEvseStatusV21WithResponse call
func ParseERoamingPushEvseStatusV21Response(rsp *http.Response) (*ERoamingPushEvseStatusV21Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingPushEvseStatusV21Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingPushEvseDataV23Response parses an HTTP response from a ERoamingPushEvseDataV23WithResponse call
func ParseERoamingPushEvseDataV23Response(rsp *http.Response) (*ERoamingPushEvseDataV23Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingPushEvseDataV23Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingChargingNotificationsV11Response parses an HTTP response from a ERoamingChargingNotificationsV11WithResponse call
func ParseERoamingChargingNotificationsV11Response(rsp *http.Response) (*ERoamingChargingNotificationsV11Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingChargingNotificationsV11Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeRemoteReservationStartV11Response parses an HTTP response from a ERoamingAuthorizeRemoteReservationStartV11WithResponse call
func ParseERoamingAuthorizeRemoteReservationStartV11Response(rsp *http.Response) (*ERoamingAuthorizeRemoteReservationStartV11Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeRemoteReservationStartV11Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseERoamingAuthorizeRemoteReservationStopV1Response parses an HTTP response from a ERoamingAuthorizeRemoteReservationStopV1WithResponse call
func ParseERoamingAuthorizeRemoteReservationStopV1Response(rsp *http.Response) (*ERoamingAuthorizeRemoteReservationStopV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ERoamingAuthorizeRemoteReservationStopV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ERoamingAcknowledgmen
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
